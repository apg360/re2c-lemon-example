/* Generated by re2c 2.0.3 on Sun Dec 20 21:41:47 2020 */
// re2c $INPUT -o $OUTPUT -i
// french : https://fr.qaz.wiki/wiki/Re2c
// english : https://wikivisually.com/wiki/re2c
// https://www.systutorials.com/docs/linux/man/1-re2c
// https://re2c.org/manual/manual_c.html

#include "../parser.h"
#pragma once

typedef enum { FAIL, OK } Result;




 // current position
 char* m_cursor;     // current_char : the next input character to be read.                     A pointer-like l-value that stores the current input position
 char* m_limit;      // last_char    : the position after the last available input character.   A pointer-like r-value that stores the end of input position
                     //                Lexer compares YYCURSOR to YYLIMIT in order to determine if there is enough input characters left
 char* m_token;      // token_char   : 
 char* m_marker;     // marker_char  : the position of the most recent match
 int m_lineno;

void increment_line_number() {
    m_lineno++;
}
int length() {
    return (m_cursor-m_token);
}
char* text() {
    return m_token; //std::string( m_token, m_token+length() );
}
int lineno() {
    return m_lineno;
}

static int SCANNER(char *str) // const char *YYCURSOR) 
{
    m_cursor = str;
    //unsigned int len;
    size_t len = strlen(str);
    m_limit = str + len;
    int wordCount = 0;                           // count word, not letters
    
loop:
    m_token = m_cursor;
    
    
        {
            char yych;
            yych = *m_cursor;
            switch (yych) {
            case '\t' ... '\n':
            case '\f' ... '\r':
            case ' ': goto yy4;
            case '*': goto yy6;
            case '+': goto yy8;
            case '-': goto yy10;
            case '/': goto yy12;
            case '1' ... '9': goto yy14;
            default:
                if (m_limit <= m_cursor) goto yyeof2;
                goto yy2;
            }
yy2:
            ++m_cursor;
            {
        printf("unexpected character: '%c(%d)'\n", *m_token, *m_token);
        goto loop;
    }
yy4:
            ++m_cursor;
            { goto loop; }
yy6:
            ++m_cursor;
            { return TOKEN_MUL; }
yy8:
            ++m_cursor;
            { return TOKEN_ADD; }
yy10:
            ++m_cursor;
            { return TOKEN_SUB; }
yy12:
            ++m_cursor;
            { return TOKEN_DIV; }
yy14:
            yych = *++m_cursor;
            switch (yych) {
            case '0' ... '9': goto yy14;
            default: goto yy16;
            }
yy16:
            {
        yylval.int_value = atoi(m_token);
        return TOKEN_INT;
    }
yyeof2:
            { return wordCount; }
        }

}
