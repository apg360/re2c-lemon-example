#pragma once

#include <stdio.h>
#include <string.h>
#include <string>
#include <fstream>

//#include <vector>
//#include <sstream>
//#include <iostream>
//#include <cstdlib>
//#include <cassert>

typedef union {
    int int_value;
} YYSTYPE;

struct ParserState {
    int result;
    ParserState() :result(0) {
    }
};

#include "parser.h"

// buffer memory
 char* m_buffer;
 // current position
 char* m_cursor;
 char* m_limit;
 char* m_token;
 char* m_marker;
 int m_buffer_size;
 int m_lineno;
 
//public

    void increment_line_number() {
        m_lineno++;
    }

    void SCANNER_INIT( std::istream *ifs_, int init_size=1024 ){
        m_buffer=0;
        m_cursor=0;
        m_limit=0;
        m_token=0;
        m_marker=0;
        m_buffer_size = init_size;
        m_lineno=1;
        
        m_buffer = new char[m_buffer_size];
        m_cursor = m_limit = m_token = m_marker = m_buffer;
        ifs = ifs_;
    }
 
    void SCANNER_DELETE() {
        delete [] m_buffer;
    }
 
    int length() {
        return (m_cursor-m_token);
    }
    std::string text() {
        return std::string( m_token, m_token+length() );
    }
    int lineno() {
        return m_lineno;
    }
 
    int SCAN(YYSTYPE& yylval) {
std:
        m_token = m_cursor;
 
    /*!re2c
        re2c:define:YYCTYPE = "char";
        re2c:define:YYCURSOR = m_cursor;
        re2c:define:YYMARKER = m_marker;
        re2c:define:YYLIMIT = m_limit;
        
        re2c:yyfill:enable = 1;
        re2c:indent:top = 2;
        re2c:indent:string="    ";

        INTEGER                = [1-9][0-9]*;
        WS                     = [ \r\n\t\f];
        ANY_CHARACTER          = [^];

        INTEGER {
            yylval.int_value = atoi(text().c_str());
            return TOKEN_INT;
        }
        "+" { return TOKEN_ADD; }
        "-" { return TOKEN_SUB; }
        "*" { return TOKEN_MUL; }
        "/" { return TOKEN_DIV; }
        WS {
            goto std;
        }
        ANY_CHARACTER {
            printf("unexpected character: '%c(%d)'\n", *m_token, *m_token);
            goto std;
        }

    */

    }

