
As explained in SQLite page : https://sqlite.org/lemon.html

With Lemon, the tokenizer (lex/flex/re2c) calls the parser
With Yacc+Bison, the parser calls tokenizer (lex/flex/re2c)



https://www.cs.fsu.edu/~langley/COP4020/2015-Summer/Lectures/Lemon-and-RE2C.html
With Lemon:
While there are many excellent guides to Bison, both commercial and free, Lemon has far fewer: the reason is simple, Lemon has far fewer quirks and oddities to document.

You don't write rules using a large number of alternatives in individual rules; rather, you split separate rules into separate cases.

All semantic actions come after the rule, not in the midst.
If you need the equivalent of an embedded semantic action, all you need to do is split the original rule into two parts: the original, and a "singleton" rule so that its reduction triggers your semantic action.

You can have the parser emit very useful information about the state of the parse by simply calling the function ParseTrace()


https://stackoverflow.com/questions/4526509/lemon-power-or-not
Reasons to use Lemon :
    (*) Small size of generated code and memory footprint. It produces the smallest parser I found (I compared parsers of similar complexity generated by flex, bison, ANTLR, and Lemon);
    (*) Excellent support of embedded systems: Lemon doesn't depend on standard library, you can specify external memory management functions, debug logging is removable.
    (*) Public domain license. There is separate fork of Lemon licensed under GPLv2 that is not suitable for our needs because of viral license. So we get latest sqlite sources and compile Lemon out of them (it consists of only two files);
    (*) Pull-parsing. It makes code more straightforward to understand and maintain than Flex/Bison parsing code. Thread-safety as an additional bonus I admire.
    (*) Simple integration with tokenizers. Our project nature requires tokenizing of binary stream with variable tokens size. It was quite an easy to implemented tokenizer and integrate with parser API of only 3 functions and one feedback context variable. We investigated ways of integrating Lemon with re2c and Ragel and found them also quite easy to implement.
    (*) Very simple syntax fast to learn.
    (*) Lemon explicitly separate development of tokenizer and lexical analyzer(parser). My development flow starts with designing of parser grammar. I'm able to check complex rules with implicit token sequence by the means of several Parser(...) calls at this first stage. Tokenizer is implemented afterwards.

Lemon is not a silver bullet, it has limited area of application. Among disadvantages:
    (*) Lemon requires to write more rules in comparison with Bison because of simplified syntax: no repetitions and optionals, one action per rule, etc.
    (*) Complete set of LALR(1) parser limitations.
    (*) Only the C language.

