/* Generated by re2c 2.0.3 on Sat Jan 23 08:25:00 2021 */
// re2c $INPUT -o $OUTPUT -i
// french : https://fr.qaz.wiki/wiki/Re2c
// english : https://wikivisually.com/wiki/re2c
// https://www.systutorials.com/docs/linux/man/1-re2c
// https://re2c.org/manual/manual_c.html
//
// With Lemon it is the lexer/tokenizer that calls/initiate the parser
// re2c calls lemon
//----------------------------------------------------------------------

// the contents of 'definitions.re2c' are copy-pasted verbatim in place of the directive
//definitions.re2c START -----------------------
#include <common.h>  // A library with most common needs when programming
#include <token.h>   // 

bool scanner_DebugMode = false;
struct _scanner_state SCANNER_STATE;

//Parser START----------------------------------------------------------
    
    // A way to access the PARSER_STATE variable of inside parser.c
    // Make sure parser.c is added at compilation time.
    // variable name must be same as the one in parser.lemon
    extern const struct _parser_state PARSER_STATE;
    //printf("Result : %f\n",PARSER_STATE.result_value.number);
    
    // header for functions in parser.c  Make sure parser.c is added at compilation time.
    void PARSER_INIT(bool parser_DebugMode);
    void PARSER(const struct _Token * pToken);
    void PARSER_FREE();
    
//Parser END-----------------------------------------------------------

/*
R* : zero or more occurrences of the regular expression R.
R+ : one or more repetition of the regular expression R.
R? : zero or one R. That means, there maybe an R or not.
*/

//definitions.re2c END -----------------------


void set_token(const int tokentype, const char* tokentypename)
{
    SCANNER_STATE.Token.type = tokentype;
    SCANNER_STATE.Token.type_name = tokentypename;
    SCANNER_STATE.column_position=(int)(SCANNER_STATE.begin - SCANNER_STATE.lexemes);
    
    // if numeric(TK_INT_LITERAL) then take input(string) and convert it to double
    if ( TK_INT_LITERAL == tokentype )
    {
      char tokenvalue_string[255];
      sprintf( tokenvalue_string, "%.*s", (int)(SCANNER_STATE.cursor - SCANNER_STATE.begin), SCANNER_STATE.begin );
      // converting string to double
      SCANNER_STATE.Token.value_is_a_number = char_to_double(tokenvalue_string);
    }
}

void SCANNER(const char *the_text)
{
    SCANNER_STATE.begin            = the_text;
    SCANNER_STATE.end              = the_text + strlen(the_text);
    SCANNER_STATE.cursor           = the_text;
    SCANNER_STATE.lexemes          = the_text;
    SCANNER_STATE.line_number      = 1;
    SCANNER_STATE.column_position  = 1;
    
    printf(" ** START Scanning : '%s'\n",the_text);
    if (scanner_DebugMode == true) printf("Number of characters %lu\n", strlen(the_text));
    
    
    
    // Infinite loop
    for (;;) 
    {
continue_scanning:
    // Reset variables
    SCANNER_STATE.begin = SCANNER_STATE.cursor;
    SCANNER_STATE.Token.type = 0;
    SCANNER_STATE.Token.value_is_a_number = 0;
    
    // If reached end of the text, last character (does not have "end");
    if ( SCANNER_STATE.cursor >= SCANNER_STATE.end )
    { 
      set_token( MACRO_VALUE_AND_NAME(TK_END_OF_FILE) );
      goto parser_now;
    };
    
    
{
	char yych;
	yych = *SCANNER_STATE.cursor;
	switch (yych) {
	case 0x00:
	case '\n':
	case '\r':	goto yy2;
	case '\t':
	case '\v':
	case '\f':
	case ' ':	goto yy7;
	case '%':	goto yy10;
	case '(':	goto yy12;
	case ')':	goto yy14;
	case '*':	goto yy16;
	case '+':	goto yy18;
	case '-':	goto yy20;
	case '/':	goto yy22;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy24;
	case '^':	goto yy27;
	default:	goto yy5;
	}
yy2:
	yych = *++SCANNER_STATE.cursor;
	switch (yych) {
	case 0x00:
	case '\n':
	case '\r':	goto yy2;
	default:	goto yy4;
	}
yy4:
	{ set_token( MACRO_VALUE_AND_NAME(TK_END_OF_LINE)     );
                        SCANNER_STATE.lexemes = SCANNER_STATE.cursor;    // remove already scanned text, remaining only unconsumed part
                        SCANNER_STATE.line_number++;                     // line counter increase +1
                        goto parser_now;
                      }
yy5:
	++SCANNER_STATE.cursor;
	{ printf("unexpected character: %c\n", *SCANNER_STATE.cursor+1); goto continue_scanning; }
yy7:
	yych = *++SCANNER_STATE.cursor;
	switch (yych) {
	case '\t':
	case '\v':
	case '\f':
	case ' ':	goto yy7;
	default:	goto yy9;
	}
yy9:
	{ goto continue_scanning;}
yy10:
	++SCANNER_STATE.cursor;
	{ set_token( MACRO_VALUE_AND_NAME(TK_MOD)         ); goto parser_now;}
yy12:
	++SCANNER_STATE.cursor;
	{ set_token( MACRO_VALUE_AND_NAME(TK_LPAREN)      ); goto parser_now;}
yy14:
	++SCANNER_STATE.cursor;
	{ set_token( MACRO_VALUE_AND_NAME(TK_RPAREN)      ); goto parser_now;}
yy16:
	++SCANNER_STATE.cursor;
	{ set_token( MACRO_VALUE_AND_NAME(TK_MUL)         ); goto parser_now;}
yy18:
	++SCANNER_STATE.cursor;
	{ set_token( MACRO_VALUE_AND_NAME(TK_ADD)         ); goto parser_now;}
yy20:
	++SCANNER_STATE.cursor;
	{ set_token( MACRO_VALUE_AND_NAME(TK_SUB)         ); goto parser_now;}
yy22:
	yych = *++SCANNER_STATE.cursor;
	switch (yych) {
	case '*':	goto yy29;
	default:	goto yy23;
	}
yy23:
	{ set_token( MACRO_VALUE_AND_NAME(TK_DIV)         ); goto parser_now;}
yy24:
	yych = *++SCANNER_STATE.cursor;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy24;
	default:	goto yy26;
	}
yy26:
	{ set_token( MACRO_VALUE_AND_NAME(TK_INT_LITERAL) ); goto parser_now;}
yy27:
	++SCANNER_STATE.cursor;
	{ set_token( MACRO_VALUE_AND_NAME(TK_EXP)         ); goto parser_now;}
yy29:
	++SCANNER_STATE.cursor;
	{ goto comment; }
}

    
comment:
    
{
	char yych;
	yych = *SCANNER_STATE.cursor;
	switch (yych) {
	case '\n':	goto yy35;
	case '*':	goto yy37;
	default:	goto yy33;
	}
yy33:
	++SCANNER_STATE.cursor;
yy34:
	{ goto comment; }
yy35:
	++SCANNER_STATE.cursor;
	{ SCANNER_STATE.line_number++; goto comment; }
yy37:
	yych = *++SCANNER_STATE.cursor;
	switch (yych) {
	case '/':	goto yy38;
	default:	goto yy34;
	}
yy38:
	++SCANNER_STATE.cursor;
	{ goto continue_scanning; }
}


parser_now:
      if (scanner_DebugMode == true) { 
        printf("Line:%d / Col:%d ", SCANNER_STATE.line_number, SCANNER_STATE.column_position);
        printf("parser(%s, %.lf) \n", SCANNER_STATE.Token.type_name, SCANNER_STATE.Token.value_is_a_number); // Formating number of digits after dot %.15lf
      }
      
      PARSER( &SCANNER_STATE.Token );
      
      // end inifinite loop when reached end of text
      if( TK_END_OF_FILE == SCANNER_STATE.Token.type ) break;
    }//end for loop
    if (scanner_DebugMode == true) puts("\n ** THE END ** \n");
}

double eval(const char *the_text)
{
    double result;
    SCANNER(the_text);
    // Access PARSER_STATE and take the result value
    result = PARSER_STATE.result_value.value_is_a_number;
    
    return result;
}
