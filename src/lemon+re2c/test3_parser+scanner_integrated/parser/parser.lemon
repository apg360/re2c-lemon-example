// https://sqlite.org/src/doc/trunk/doc/lemon.html
// https://sqlite.org/src/doc/trunk/doc/lemon.html#token_type
// http://souptonuts.sourceforge.net/readme_lemon_tutorial.html

%syntax_error  { PARSER_STATE->error = true; fprintf(stderr, "Syntax Error.\n"); }
%parse_failure { PARSER_STATE->error = true; fprintf(stderr, "Parse failure.\n"); }

// must call PARSER(0, 0); to enter parse_accept
%parse_accept  { PARSER_STATE->error = false; printf(" ** Parser Result : %.lf\n",PARSER_STATE->result_value.number); printf("The parser has completed successfully.\n"); } // Formating number of digits after dot %.15lf

%include
{
    #include <stdlib.h>  // malloc, free + os access: open file, read/write file, delete file etc...
    #include <string.h>  // strlen, strcmp
    #include <stdbool.h> // bool
    #include <parser.h>  // All token codes definitions, generated by grammar in lemon
    #include <token.h>   // 
    
    void * theParser;
    struct _parser_state PARSER_STATE;
    
    void ParseTrace(FILE *TraceFILE, char *str);
    void * ParseAlloc(
        void * (*allocProc)(size_t)             // Function used to allocate memory
    );
    void ParseFree(
        void* parser,                          // The parser to be deleted
        void(*freeProc)(void*)                 // Function used to reclaim memory
    );
    void Parse(
        void * pParser,                        // The parser
        const int pTokentype,                  // The major token code number
        const union _Tokenvalue pTokenvalue,   // Value associated with a token %token_type { double }
        struct _parser_state * pPARSER_STATE   // %extra_argument parameter
    );
    
    void PARSER_INIT(bool parser_DebugMode){
      theParser = ParseAlloc(malloc);
      if (parser_DebugMode == true) ParseTrace(stderr, "[Parser] >> ");
    }
    void PARSER(const struct _Token * pToken){
      
      //printf("inside PARSER, %s=%.d\n", pToken->type, pToken->code);
      //printf("PARSER (%d ,%.lf) \n", pToken->type, pToken->value.number);
      
      if ( TK_NEWLINE == pToken->type )
      {
        // PARSER(TK_NEWLINE, 0); + PARSER(0, 0);
        Parse(theParser, pToken->type, pToken->value, &PARSER_STATE);
        Parse(theParser, 0, (union _Tokenvalue){.number=0}, &PARSER_STATE);
      }
      else 
      {
        Parse(theParser, pToken->type, pToken->value, &PARSER_STATE);
      }
    }
    void PARSER_FREE(){
      ParseFree(theParser, free);
    }

} // end %include

%extra_argument  { struct _parser_state * PARSER_STATE }
%token_prefix TK_ // All token codes are integers with #defines that begin with "TK_"

%token_type      { union _Tokenvalue }

// Math order of priority => BIDMAS : Bracket/Parenthesis Index Divide Multiply Addition Substraction
%left ADD SUB.       //PLUS   MINUS
%left DIV MUL.       //DIVIDE TIMES

// This is to terminate with a new line, the grammar dictate when the expression can no longer be reduced.
// Without this PARSER(0, 0); Parse(pParse,0,0) have to be called to signal the end of the input for an expression
start ::= in.
in ::= .
in ::= in program NEWLINE. // NEWLINE is EOL : end of line

program ::= expr(A).   { PARSER_STATE->result_value.number = A.number; }

expr(X) ::= expr(A) ADD  expr(B).    { X.number = A.number + B.number; }
expr(X) ::= expr(A) SUB  expr(B).    { X.number = A.number - B.number; }
expr(X) ::= expr(A) MUL  expr(B).    { X.number = A.number * B.number; }
expr(X) ::= expr(A) DIV  expr(B).    { if(B.number != 0){ X.number = A.number / B.number; 
                                       }else{ printf("/!\\ warning divide by zero\n" ); PARSER_STATE->error = true;} 
                                     }// end of DIVIDE

expr(X) ::= LPAREN expr(A) RPAREN.   { X.number = A.number; }

expr(X) ::= INT_LITERAL(A).          { X.number = A.number; }
