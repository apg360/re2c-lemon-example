// https://sqlite.org/src/doc/trunk/doc/lemon.html
// https://sqlite.org/src/doc/trunk/doc/lemon.html#token_type
// http://souptonuts.sourceforge.net/readme_lemon_tutorial.html

/*
    <> (inequality) 							- use != instead will be : not=
    add (concatenation (strings)) 				- use + instead
    eq (equality (strings)) 					- use == instead
    ne (not equal (strings)) 					- use != instead will be : not=
    lt (less than (strings)) 					- use < instead
    le (less than or equal to (strings)) 		- use <= instead
    gt (greater than (strings)) 				- use > instead
    ge (greater than or equal to (strings)) 	- use >= instead
    and (logical and) 							- use && instead mine will be : and
    or (logical or) 							- use || instead mine will be : or
    not (logical not) 							- use ! instead  mine will be : not
*/

%syntax_error  { PARSER_STATE->error = true; fprintf(stderr, "Syntax Error.\n"); }
%parse_failure { PARSER_STATE->error = true; fprintf(stderr, "Parse failure.\n"); }

// must call PARSER(0, 0); to enter %parse_accept
// Formating number of digits after dot %.15lf
%parse_accept  { PARSER_STATE->error = false;
                 printf(" ** Parser Result : %.lf\n",PARSER_STATE->result_value.value_is_a_number);
                 // puts("The parser has completed successfully.");
               }

%include
{
    #include <stdlib.h>  // malloc, free + os access: open file, read/write file, delete file etc...
    #include <string.h>  // strlen, strcmp
    #include <stdbool.h> // bool
    #include <math.h>
    #include <parser.h>  // All token codes definitions, generated by grammar in lemon
    #include <token.h>   // 
    
    void * theParser;
    struct _parser_state PARSER_STATE;
    
    void ParseTrace(FILE *TraceFILE, char *str);
    void * ParseAlloc(
        void * (*allocProc)(size_t)             // Function used to allocate memory
    );
    void ParseFree(
        void* parser,                          // The parser to be deleted
        void(*freeProc)(void*)                 // Function used to reclaim memory
    );
    void Parse(
        void * pParser,                        // The parser
        const int pTokentype,                  // The major token code number
        const double pTokenvalue,              // Value associated with a token %token_type { double }
        struct _parser_state * pPARSER_STATE   // %extra_argument parameter
    );
    
    void PARSER_INIT(bool parser_DebugMode){
      theParser = ParseAlloc(malloc);
      if ( parser_DebugMode == true ) ParseTrace(stderr, "[Parser] >> ");
    }
    void PARSER(const struct _Token * pToken){
      
      // Reset variables
      PARSER_STATE.result_value.value_is_a_number = 0;
      
      if ( TK_NEWLINE == pToken->type || TK_END_OF_LINE == pToken->type )
      {
        // PARSER(TK_NEWLINE,0); or PARSER(TK_END_OF_LINE,0);
        Parse(theParser, pToken->type, pToken->value_is_a_number, &PARSER_STATE);
        // must call PARSER(0, 0); to enter %parse_accept
        Parse(theParser, 0, 0, &PARSER_STATE);
      }
      else 
      {
        Parse(theParser, pToken->type, pToken->value_is_a_number, &PARSER_STATE);
      }
    }
    void PARSER_FREE(){
      ParseFree(theParser, free);
    }

} // end %include

%extra_argument  { struct _parser_state * PARSER_STATE }
%token_prefix TK_ // All token codes are integers with #defines that begin with "TK_"

%token_type      { double }

// Math order of priority => BIDMAS : Bracket/Parenthesis Indices/Power/Order Divide Multiply Addition Substraction
%nonassoc AND OR EQ NE GT GE LT LE.
%left ADD SUB.       // PLUS   MINUS
%left DIV MUL MOD.   // DIVIDE TIMES MODULUS(remainder operator)
%left POS NEG.       // Negation--unary minus
%right EXP.          // 2^3^2 = 2^(3^2) = 512
%left LPAREN RPAREN.

// This is to terminate with a new line, the grammar dictate when the expression can no longer be reduced.
// Without this PARSER(0, 0); Parse(pParse,0,0) have to be called to signal the end of the input for an expression
start ::= in.
in ::= .
in ::= in expression END_OF_LINE.
in ::= in expression NEWLINE.

expression ::= expr(A).             { PARSER_STATE->result_value.value_is_a_number = A; }

expr(X) ::= expr(A) ADD expr(B).    { X = A + B; }
expr(X) ::= expr(A) SUB expr(B).    { X = A - B; }
expr(X) ::= expr(A) MUL expr(B).    { X = A * B; }
expr(X) ::= expr(A) DIV expr(B).    { if(B != 0){ X = A / B; 
                                        }else{ puts("/!\\ warning divide by zero" ); X = 0; PARSER_STATE->error = true;} 
                                    } // end of DIVIDE
expr(X) ::= expr(A) MOD expr(B).    { X = fmod(A, B ); } // A % B cannot be done on double
expr(X) ::= expr(A) EXP expr(B).    { X = pow(A, B); } // Exponentiation

expr(X) ::= LPAREN expr(A) RPAREN.  { X = A; }

expr(X) ::= ADD expr(A). [POS]      { X = A; }

expr(X) ::= SUB expr(A). [NEG]      { X = A * -1; } // Negation--unary minus

expr(X) ::= INT_LITERAL(A).         { X = A; }

