/* Generated by re2c 2.0.3 on Thu Jan  7 02:23:44 2021 */
// re2c $INPUT -o $OUTPUT -i
// french : https://fr.qaz.wiki/wiki/Re2c
// english : https://wikivisually.com/wiki/re2c
// https://www.systutorials.com/docs/linux/man/1-re2c
// https://re2c.org/manual/manual_c.html
//
// With Lemon it is the lexer/tokenizer that calls/initiate the parser
// re2c calls lemon
//----------------------------------------------------------------------

struct scanner_state* s;

// the contents of 'definitions.re2c' are copy-pasted verbatim in place of the directive
//definitions.re2c START -----------------------
#include "../include/common.h"

typedef enum { FAIL, OK } Result; //typedef enum { false, true } bool; // 0, 1
enum Token_value {
  NAME, NUMBER, END, INC, DEC,
  PLUS='+', MINUS='-', MUL='*', DIV='/',
  PRINT=';', ASSIGN='=', LP='(', RP=')', LB='{', RB='}'
};


bool DebugMode = false;

struct scanner_state
{
    const char *cursor;             //current_char
    const char *begin;              //first_char
    const char *end;                //last_char , limit, YYLIMIT
    const char *marker;             //marker - the position of the most recent match
    
    int line;                       //line number
    const char *column_position;    // position, column number on the line
};

// https://data-flair.training/blogs/union-in-c-language/
// union means only one member can be accessed at a time in a union.
// Only one data member of a union can be accessed at one time.
// Not a struct with many members but a struct with one single member, that can be one of those.
// A union prohibits the initialization of all its data members. The first member of the union can only be initialized through an object.
// ll the data members of a union share the same memory location. Hence, changes made in one data member inevitably affects the other.
union scanner_token
{
    int num;
};

void println(const char *str) {
  printf("%s\n",str);
}

/*
R* : zero or more occurrences of the regular expression R.
R+ : one or more repetition of the regular expression R.
R? : zero or one R. That means, there maybe an R or not.
*/

//definitions.re2c END -----------------------


static const char *SCANNER(const char *str)
{
    s->cursor = str;              // current_char : the next input character to be read.                     A pointer-like l-value that stores the current input position
    s->begin = str;
    s->end = str + strlen(str);   // last_char    : the position after the last available input character.   A pointer-like r-value that stores the end of input position
                                  //                Lexer compares YYCURSOR to YYLIMIT in order to determine if there is enough input characters left
    
    
    const char *lexeme;                          // the next input to be scanned.
    char *the_match;                             // the current matched value
    union scanner_token *token;
    
    if (DebugMode == true) printf("Scanning : '%s'\n",str);
    if (DebugMode == true) printf("Number of characters %lu\n", strlen(str));
    
    //infinite for loop
    for (;;) {
loop:
    lexeme = s->cursor;
    
    // if lexeme != "" then
    // The expression lexeme == "" checks if the two pointers are the same (point to the same memory location).
    // The expression strcmp( lexeme, "") == 0 will check if the contents of the two strings are the same.
    /*
        'a' means the value of the character a.
        "a" means the address of the memory location where the string "a" is stored 
        (which will generally be in the data section of your program's memory space).
        At that memory location, you will have two bytes -- the character 'a' and the null terminator for the string.
    */
    if (strcmp( str, lexeme) == 0) printf("\n>strcmp value: %u\n", strcmp(str, lexeme));
    if (strcmp( lexeme, "") != 0) printf("> lexeme : '%s'\n",lexeme);
        
{
	char yych;
	unsigned int yyaccept = 0;
	yych = *s->cursor;
	switch (yych) {
	case '\t':
	case '\n':
	case '\v':
	case '\f':
	case '\r':
	case ' ':	goto yy4;
	case '!':	goto yy7;
	case '(':	goto yy8;
	case ')':	goto yy10;
	case '*':	goto yy12;
	case '+':	goto yy14;
	case ',':	goto yy16;
	case '-':	goto yy18;
	case '.':	goto yy20;
	case '/':	goto yy22;
	case '0':	goto yy24;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy26;
	case '<':	goto yy28;
	case '=':	goto yy30;
	case '>':	goto yy32;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy34;
	case '_':	goto yy37;
	case '{':	goto yy39;
	case '}':	goto yy41;
	default:	goto yy2;
	}
yy2:
	++s->cursor;
yy3:
	{ return "default rule"; }
yy4:
	yych = *++s->cursor;
	switch (yych) {
	case '\t':
	case '\n':
	case '\v':
	case '\f':
	case '\r':
	case ' ':	goto yy4;
	default:	goto yy6;
	}
yy6:
	{ println("token_wsp"); continue;}
yy7:
	yych = *++s->cursor;
	switch (yych) {
	case '=':	goto yy43;
	default:	goto yy3;
	}
yy8:
	++s->cursor;
	{ println("token_parenthesis"); continue;}
yy10:
	++s->cursor;
	{ println("token_parenthesis"); continue;}
yy12:
	++s->cursor;
	{ println("TOKEN_TIMES");    continue;}
yy14:
	++s->cursor;
	{ println("TOKEN_PLUS");     continue;}
yy16:
	++s->cursor;
	{ println("token_comma"); continue;}
yy18:
	++s->cursor;
	{ println("TOKEN_MINUS");    continue;}
yy20:
	++s->cursor;
	{ println("token_dot"); continue;}
yy22:
	++s->cursor;
	{ println("TOKEN_DIVIDE");   continue;}
yy24:
	yyaccept = 0;
	yych = *(s->marker = ++s->cursor);
	switch (yych) {
	case 'B':
	case 'b':	goto yy53;
	case 'X':
	case 'x':	goto yy54;
	default:	goto yy50;
	}
yy25:
	{ println("TOKEN_INTEGER"); printf("> %f \n",atof(lexeme)); token->num = atof(lexeme); continue;}
yy26:
	yyaccept = 0;
	yych = *(s->marker = ++s->cursor);
	switch (yych) {
	case 0x00:	goto yy55;
	case '\t':
	case '\v':
	case '\f':
	case ' ':	goto yy57;
	case '\n':	goto yy59;
	case '\r':	goto yy60;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy26;
	default:	goto yy25;
	}
yy28:
	yych = *++s->cursor;
	switch (yych) {
	case '=':	goto yy61;
	default:	goto yy29;
	}
yy29:
	{ println("token_CLT"); continue;}
yy30:
	yych = *++s->cursor;
	switch (yych) {
	case '=':	goto yy63;
	default:	goto yy31;
	}
yy31:
	{ println("token_equal"); continue;}
yy32:
	yych = *++s->cursor;
	switch (yych) {
	case '=':	goto yy65;
	default:	goto yy33;
	}
yy33:
	{ println("token_CGT"); continue;}
yy34:
	yych = *++s->cursor;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy34;
	default:	goto yy36;
	}
yy36:
	{
                    println("token_IDENTIFIER, value=");
                    //fprintf(stderr, "%.*s", (int)(str - lexeme), lexeme);
                    printf("IDENTIFIER (\'%.*s\')", (int)(lexeme - str), str);
                    continue;
                   }
yy37:
	yych = *++s->cursor;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy34;
	default:	goto yy38;
	}
yy38:
	{ println("token_underscore"); continue;}
yy39:
	++s->cursor;
	{ println("token_lbrace"); continue;}
yy41:
	++s->cursor;
	{ println("token_rbrace"); continue;}
yy43:
	++s->cursor;
	{ println("token_CNE"); continue;}
yy45:
	++s->cursor;
	{ printf ("%s: %s\n", "oct", lexeme); return "oct"; }
yy47:
	yych = *++s->cursor;
	switch (yych) {
	case '\n':	goto yy45;
	default:	goto yy48;
	}
yy48:
	s->cursor = s->marker;
	if (yyaccept == 0) {
		goto yy25;
	} else {
		goto yy56;
	}
yy49:
	yyaccept = 0;
	yych = *(s->marker = ++s->cursor);
yy50:
	switch (yych) {
	case 0x00:
	case '\n':	goto yy45;
	case '\r':	goto yy47;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':	goto yy49;
	case '8':
	case '9':	goto yy51;
	default:	goto yy25;
	}
yy51:
	yych = *++s->cursor;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy51;
	default:	goto yy25;
	}
yy53:
	yych = *++s->cursor;
	switch (yych) {
	case '0':
	case '1':	goto yy67;
	default:	goto yy48;
	}
yy54:
	yych = *++s->cursor;
	switch (yych) {
	case 0x00:
	case '\n':
	case '\r':	goto yy48;
	default:	goto yy70;
	}
yy55:
	++s->cursor;
yy56:
	{ printf ("%s: %s\n", "dec", lexeme); return "dec"; }
yy57:
	yych = *++s->cursor;
yy58:
	switch (yych) {
	case '\t':
	case '\n':
	case '\v':
	case '\f':
	case '\r':
	case ' ':	goto yy57;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy71;
	default:	goto yy48;
	}
yy59:
	yyaccept = 1;
	yych = *(s->marker = ++s->cursor);
	switch (yych) {
	case '\t':
	case '\n':
	case '\v':
	case '\f':
	case '\r':
	case ' ':	goto yy57;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy71;
	default:	goto yy56;
	}
yy60:
	yych = *++s->cursor;
	switch (yych) {
	case '\n':	goto yy59;
	default:	goto yy58;
	}
yy61:
	++s->cursor;
	{ println("token_CLE"); continue;}
yy63:
	++s->cursor;
	{ println("token_CEQ"); continue;}
yy65:
	++s->cursor;
	{ println("token_CGE"); continue;}
yy67:
	yych = *++s->cursor;
	switch (yych) {
	case 0x00:
	case '\n':	goto yy73;
	case '\r':	goto yy75;
	case '0':
	case '1':	goto yy67;
	default:	goto yy48;
	}
yy69:
	yych = *++s->cursor;
yy70:
	switch (yych) {
	case 0x00:
	case '\n':	goto yy76;
	case '\r':	goto yy78;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy69;
	default:	goto yy48;
	}
yy71:
	yych = *++s->cursor;
	switch (yych) {
	case 0x00:
	case '\n':	goto yy79;
	case '\r':	goto yy81;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy71;
	default:	goto yy48;
	}
yy73:
	++s->cursor;
	{ printf ("%s: %s\n", "bin", lexeme); return "bin"; }
yy75:
	yych = *++s->cursor;
	switch (yych) {
	case '\n':	goto yy73;
	default:	goto yy48;
	}
yy76:
	++s->cursor;
	{ printf ("%s: %s\n", "hex", lexeme); return "hex"; }
yy78:
	yych = *++s->cursor;
	switch (yych) {
	case '\n':	goto yy76;
	default:	goto yy48;
	}
yy79:
	++s->cursor;
	{ printf ("%s: %s\n", "dec wsp dec", lexeme); return "dec wsp dec"; }
yy81:
	yych = *++s->cursor;
	switch (yych) {
	case '\n':	goto yy79;
	default:	goto yy48;
	}
}

    }
}

