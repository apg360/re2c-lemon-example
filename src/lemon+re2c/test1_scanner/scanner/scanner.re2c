// re2c $INPUT -o $OUTPUT -i
// french : https://fr.qaz.wiki/wiki/Re2c
// english : https://wikivisually.com/wiki/re2c
// https://www.systutorials.com/docs/linux/man/1-re2c
// https://re2c.org/manual/manual_c.html
//
// With Lemon it is the lexer/tokenizer that calls/initiate the parser
// re2c calls lemon
//----------------------------------------------------------------------

// the contents of 'definitions.re2c' are copy-pasted verbatim in place of the directive
/*!include:re2c "definitions.re2c"*/

static const char *SCANNER(const char *str)
{
    unsigned int lensize = strlen(str);
    const char *YYCURSOR = str;                  // current_char : the next input character to be read.                     A pointer-like l-value that stores the current input position
    const char *YYLIMIT = str + lensize;         // last_char    : the position after the last available input character.   A pointer-like r-value that stores the end of input position
                                                                // Lexer compares YYCURSOR to YYLIMIT in order to determine if there is enough input characters left
    const char *YYMARKER;                        // marker_char  : the position of the most recent match
    const char *lexeme;                          // the next input to be scanned.
    
    if (DebugMode == true) printf("Scanning : '%s'\n",str);
    if (DebugMode == true) printf("Number of characters %u\n",lensize);
    
loop:
    lexeme = YYCURSOR;
    // if lexeme != "" then
    // The expression lexeme == "" checks if the two pointers are the same (point to the same memory location).
    // The expression strcmp( lexeme, "") == 0 will check if the contents of the two strings are the same.
    /*
        'a' means the value of the character a.
        "a" means the address of the memory location where the string "a" is stored 
        (which will generally be in the data section of your program's memory space).
        At that memory location, you will have two bytes -- the character 'a' and the null terminator for the string.
    */
    if (strcmp( lexeme, "") != 0) printf("> lexeme : '%s'\n",lexeme);
    
    /*!re2c                                      // start of re2c block
    re2c:define:YYCTYPE = char;                  // The type of the input characters (code units). For ASCII, EBCDIC and UTF-8 encodings it should be 1-byte unsigned integer.
    re2c:yyfill:enable = 0;                      // configuration
    end = "\x00";                                // LF(Line Feed)=10 CR(Carriage Return)=13  https://www.eso.org/~ndelmott/ascii.html
    
    // Default rule
    *       { printf ("%s: %s\n", "err", lexeme); return "err"; }
    
    //When this are found they are one time scan, the scan stop after finding this.
    bin end { printf ("%s: %s\n", "bin", lexeme); return "bin"; }
    oct end { printf ("%s: %s\n", "oct", lexeme); return "oct"; }
    dec end { printf ("%s: %s\n", "dec", lexeme); return "dec"; }
    hex end { printf ("%s: %s\n", "hex", lexeme); return "hex"; }
    dec wsp dec end { printf ("%s: %s\n", "dec wsp dec", lexeme); return "dec wsp dec"; }
    
    //Scan this and continue scanning
    IDENTIFIER end{ printf ("%s: %s\n", "identifier", str); return "identifier"; }
    word { println("token_word"); goto loop;}
    number { println("TOKEN_INTEGER"); goto loop;}
    wsp { println("token_wsp"); goto loop;}
    "+" { println("TOKEN_PLUS");     goto loop; }
    "-" { println("TOKEN_MINUS");    goto loop; }
    "*" { println("TOKEN_TIMES");    goto loop; }
    "/" { println("TOKEN_DIVIDE");   goto loop; }
    "(" { println("token_parenthesis"); goto loop; }
    ")" { println("token_parenthesis"); goto loop; }
    "_" { println("token_underscore"); goto loop; }
    
    */
}

