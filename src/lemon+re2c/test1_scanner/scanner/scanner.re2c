// re2c $INPUT -o $OUTPUT -i
// french : https://fr.qaz.wiki/wiki/Re2c
// english : https://wikivisually.com/wiki/re2c
// https://www.systutorials.com/docs/linux/man/1-re2c
// https://re2c.org/manual/manual_c.html
//
// With Lemon it is the lexer/tokenizer that calls/initiate the parser
// re2c calls lemon
//----------------------------------------------------------------------

struct scanner_state* s;

// the contents of 'definitions.re2c' are copy-pasted verbatim in place of the directive
/*!include:re2c "definitions.re2c"*/

static const char *SCANNER(const char *str)
{
    s->cursor = str;              // current_char : the next input character to be read.                     A pointer-like l-value that stores the current input position
    s->begin = str;
    s->end = str + strlen(str);   // last_char    : the position after the last available input character.   A pointer-like r-value that stores the end of input position
                                  //                Lexer compares YYCURSOR to YYLIMIT in order to determine if there is enough input characters left
    
    
    const char *lexeme;                          // the next input to be scanned.
    char *the_match;                             // the current matched value
    union scanner_token *token;
    
    if (DebugMode == true) printf("Scanning : '%s'\n",str);
    if (DebugMode == true) printf("Number of characters %lu\n", strlen(str));
    
    //infinite for loop
    for (;;) {
loop:
    lexeme = s->cursor;
    
    // if lexeme != "" then
    // The expression lexeme == "" checks if the two pointers are the same (point to the same memory location).
    // The expression strcmp( lexeme, "") == 0 will check if the contents of the two strings are the same.
    /*
        'a' means the value of the character a.
        "a" means the address of the memory location where the string "a" is stored 
        (which will generally be in the data section of your program's memory space).
        At that memory location, you will have two bytes -- the character 'a' and the null terminator for the string.
    */
    if (strcmp( str, lexeme) == 0) printf("\n>strcmp value: %u\n", strcmp(str, lexeme));
    if (strcmp( lexeme, "") != 0) printf("> lexeme : '%s'\n",lexeme);
        /*!re2c                                      // start of re2c block
        re2c:define:YYCURSOR = s->cursor;
        re2c:define:YYMARKER = s->marker;
        re2c:define:YYCTYPE = char;                  // The type of the input characters (code units). For ASCII, EBCDIC and UTF-8 encodings it should be 1-byte unsigned integer.
        re2c:yyfill:enable = 0;                      // configuration
        
        // Default rule
        *       { return "default rule"; }
        
        //When this are found they are one time scan, the scan stop after finding this.
        bin end { printf ("%s: %s\n", "bin", lexeme); return "bin"; }
        oct end { printf ("%s: %s\n", "oct", lexeme); return "oct"; }
        dec end { printf ("%s: %s\n", "dec", lexeme); return "dec"; }
        hex end { printf ("%s: %s\n", "hex", lexeme); return "hex"; }
        dec wsp dec end { printf ("%s: %s\n", "dec wsp dec", lexeme); return "dec wsp dec"; }
        
        //Scan this and continue scanning
        wsp { println("token_wsp"); continue;}
        "_" { println("token_underscore"); continue;}
        "+" { println("TOKEN_PLUS");     continue;}
        "-" { println("TOKEN_MINUS");    continue;}
        "*" { println("TOKEN_TIMES");    continue;}
        "/" { println("TOKEN_DIVIDE");   continue;}
        "(" { println("token_parenthesis"); continue;}
        ")" { println("token_parenthesis"); continue;}
        "{" { println("token_lbrace"); continue;}
        "}" { println("token_rbrace"); continue;}
        "." { println("token_dot"); continue;}
        "," { println("token_comma"); continue;}
        "="  { println("token_equal"); continue;}
        "==" { println("token_CEQ"); continue;}
        "!=" { println("token_CNE"); continue;}
        "<"  { println("token_CLT"); continue;}
        "<=" { println("token_CLE"); continue;}
        ">"  { println("token_CGT"); continue;}
        ">=" { println("token_CGE"); continue;}
        IDENTIFIER {
                    println("token_IDENTIFIER, value=");
                    //fprintf(stderr, "%.*s", (int)(str - lexeme), lexeme);
                    printf("IDENTIFIER (\'%.*s\')", (int)(lexeme - str), str);
                    continue;
                   }
        word { println("token_word"); continue;}
        number { println("TOKEN_INTEGER"); printf("> %f \n",atof(lexeme)); token->num = atof(lexeme); continue;}
        */
    }
}

