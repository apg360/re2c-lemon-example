/* Generated by re2c 2.0.3 on Tue Jan  5 18:22:58 2021 */
// re2c $INPUT -o $OUTPUT -i
// french : https://fr.qaz.wiki/wiki/Re2c
// english : https://wikivisually.com/wiki/re2c
// https://www.systutorials.com/docs/linux/man/1-re2c
// https://re2c.org/manual/manual_c.html
//
// With Lemon it is the lexer/tokenizer that calls/initiate the parser
// re2c calls lemon
//----------------------------------------------------------------------

// the contents of 'definitions.re2c' are copy-pasted verbatim in place of the directive
//definitions.re2c START -----------------------
#include "../include/common.h"

typedef enum { FAIL, OK } Result; //typedef enum { false, true } bool; // 0, 1

bool DebugMode = false;

struct scanner_state
{
    const char *cursor; //start  - current_char
    const char *limit;  //end    - last_char
    const char *marker; //marker - the position of the most recent match
};

// https://data-flair.training/blogs/union-in-c-language/
// union means only one member can be accessed at a time in a union.
// Only one data member of a union can be accessed at one time.
// Not a struct with many members but a struct with one single member, that can be one of those.
// A union prohibits the initialization of all its data members. The first member of the union can only be initialized through an object.
// ll the data members of a union share the same memory location. Hence, changes made in one data member inevitably affects the other.
union scanner_token
{
    int num;
};

void println(const char *str) {
  printf("%s\n",str);
}

/*
R* : zero or more occurrences of the regular expression R.
R+ : one or more repetition of the regular expression R.
R? : zero or one R. That means, there maybe an R or not.
*/

//definitions.re2c END -----------------------


static const char *SCANNER(const char *str)
{
    unsigned int lensize = strlen(str);
    const char *YYCURSOR = str;                  // current_char : the next input character to be read.                     A pointer-like l-value that stores the current input position
    const char *YYLIMIT = str + lensize;         // last_char    : the position after the last available input character.   A pointer-like r-value that stores the end of input position
                                                                // Lexer compares YYCURSOR to YYLIMIT in order to determine if there is enough input characters left
    const char *YYMARKER;                        // marker_char  : the position of the most recent match
    const char *lexeme;                          // the next input to be scanned.
    
    if (DebugMode == true) printf("Scanning : '%s'\n",str);
    if (DebugMode == true) printf("Number of characters %u\n",lensize);
    
loop:
    lexeme = YYCURSOR;
    // if lexeme != "" then
    // The expression lexeme == "" checks if the two pointers are the same (point to the same memory location).
    // The expression strcmp( lexeme, "") == 0 will check if the contents of the two strings are the same.
    /*
        'a' means the value of the character a.
        "a" means the address of the memory location where the string "a" is stored 
        (which will generally be in the data section of your program's memory space).
        At that memory location, you will have two bytes -- the character 'a' and the null terminator for the string.
    */
    if (strcmp( lexeme, "") != 0) printf("> lexeme : '%s'\n",lexeme);
    
    
{
	char yych;
	unsigned int yyaccept = 0;
	yych = *YYCURSOR;
	switch (yych) {
	case '\t':
	case '\n':
	case '\v':
	case '\f':
	case '\r':
	case ' ':	goto yy4;
	case '(':	goto yy7;
	case ')':	goto yy9;
	case '*':	goto yy11;
	case '+':	goto yy13;
	case '-':	goto yy15;
	case '/':	goto yy17;
	case '0':	goto yy19;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy21;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy23;
	case '_':	goto yy26;
	default:	goto yy2;
	}
yy2:
	++YYCURSOR;
	{ printf ("%s: %s\n", "err", lexeme); return "err"; }
yy4:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case '\n':
	case '\v':
	case '\f':
	case '\r':
	case ' ':	goto yy4;
	default:	goto yy6;
	}
yy6:
	{ println("token_wsp"); goto loop;}
yy7:
	++YYCURSOR;
	{ println("token_parenthesis"); goto loop; }
yy9:
	++YYCURSOR;
	{ println("token_parenthesis"); goto loop; }
yy11:
	++YYCURSOR;
	{ println("TOKEN_TIMES");    goto loop; }
yy13:
	++YYCURSOR;
	{ println("TOKEN_PLUS");     goto loop; }
yy15:
	++YYCURSOR;
	{ println("TOKEN_MINUS");    goto loop; }
yy17:
	++YYCURSOR;
	{ println("TOKEN_DIVIDE");   goto loop; }
yy19:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'B':
	case 'b':	goto yy34;
	case 'X':
	case 'x':	goto yy36;
	default:	goto yy31;
	}
yy20:
	{ println("TOKEN_INTEGER"); goto loop;}
yy21:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 0x00:	goto yy37;
	case '\t':
	case '\n':
	case '\v':
	case '\f':
	case '\r':
	case ' ':	goto yy39;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy21;
	default:	goto yy20;
	}
yy23:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 0x00:	goto yy41;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case '_':	goto yy43;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy23;
	default:	goto yy25;
	}
yy25:
	{ println("token_word"); goto loop;}
yy26:
	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 0x00:	goto yy41;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy43;
	default:	goto yy27;
	}
yy27:
	{ println("token_underscore"); goto loop; }
yy28:
	++YYCURSOR;
	{ printf ("%s: %s\n", "oct", lexeme); return "oct"; }
yy30:
	yych = *++YYCURSOR;
yy31:
	switch (yych) {
	case 0x00:	goto yy28;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':	goto yy30;
	case '8':
	case '9':	goto yy32;
	default:	goto yy20;
	}
yy32:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy32;
	default:	goto yy20;
	}
yy34:
	yych = *++YYCURSOR;
	if (yych >= 0x01) goto yy46;
yy35:
	YYCURSOR = YYMARKER;
	switch (yyaccept) {
	case 0:
		goto yy20;
	case 1:
		goto yy25;
	default:
		goto yy27;
	}
yy36:
	yych = *++YYCURSOR;
	if (yych <= 0x00) goto yy35;
	goto yy48;
yy37:
	++YYCURSOR;
	{ printf ("%s: %s\n", "dec", lexeme); return "dec"; }
yy39:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case '\n':
	case '\v':
	case '\f':
	case '\r':
	case ' ':	goto yy39;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy49;
	default:	goto yy35;
	}
yy41:
	++YYCURSOR;
	{ printf ("%s: %s\n", "identifier", str); return "identifier"; }
yy43:
	yych = *++YYCURSOR;
	switch (yych) {
	case 0x00:	goto yy41;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy43;
	default:	goto yy35;
	}
yy45:
	yych = *++YYCURSOR;
yy46:
	switch (yych) {
	case 0x00:	goto yy51;
	case '0':
	case '1':	goto yy45;
	default:	goto yy35;
	}
yy47:
	yych = *++YYCURSOR;
yy48:
	switch (yych) {
	case 0x00:	goto yy53;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy47;
	default:	goto yy35;
	}
yy49:
	yych = *++YYCURSOR;
	switch (yych) {
	case 0x00:	goto yy55;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy49;
	default:	goto yy35;
	}
yy51:
	++YYCURSOR;
	{ printf ("%s: %s\n", "bin", lexeme); return "bin"; }
yy53:
	++YYCURSOR;
	{ printf ("%s: %s\n", "hex", lexeme); return "hex"; }
yy55:
	++YYCURSOR;
	{ printf ("%s: %s\n", "dec wsp dec", lexeme); return "dec wsp dec"; }
}

}

