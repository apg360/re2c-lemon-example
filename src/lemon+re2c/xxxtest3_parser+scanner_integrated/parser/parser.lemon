// https://sqlite.org/src/doc/trunk/doc/lemon.html
// http://souptonuts.sourceforge.net/readme_lemon_tutorial.html

%include
{
    #include <stdlib.h>
    #include <stdbool.h>
    #include <parser.h>  // All token codes definitions, generated by grammar in lemon
    #include <token.h>   // 
    
    struct parser_state {
        union Token result_value;
        bool error;
    };
    
    void ParseTrace(FILE *TraceFILE, char *str);
    void * ParseAlloc(
        void* (*allocProc)(size_t)           // Function used to allocate memory
    );
    void ParseFree(
        void* parser,                        // The parser to be deleted
        void(*freeProc)(void*)               // Function used to reclaim memory
    );
    void Parse(
        void * parser,                       // The parser
        const int token,                     // The major token code number
        const union Token tokenvalue,             // Value associated with a token %token_type { double }
        struct parser_state * PARSER_STATE   // %extra_argument parameter
    );

    void * theParser;
    struct parser_state PARSER_STATE;
    
    void PARSER_INIT(bool parser_DebugMode){
      theParser = ParseAlloc(malloc);
      if (parser_DebugMode == true) ParseTrace(stderr, "[Parser] >> ");
    }
    void PARSER(const int token, const union Token tokenvalue){
      Parse(theParser, token, tokenvalue, &PARSER_STATE);
    }
    void PARSER_FREE(){
      ParseFree(theParser, free);
    }

} // end %include

%extra_argument { struct parser_state * PARSER_STATE }
%token_prefix TK_ // All token codes are integers with #defines that begin with "TK_"

%token_type      { union Token }
%default_type    { union Token }
%type expression { union Token }

%left ADD SUB.       //PLUS  MINUS
%left MUL DIV.       //TIMES DIVIDE

// This is to terminate with a new line, the grammar dictate when the expression can no longer be reduced.
// Without this PARSER(0, 0); Parse(pParse,0,0) have to be called to signal the end of the input for an expression
start ::= in.
in ::= .
in ::= in program NEWLINE. // NEWLINE is EOL : end of line

program ::= expr(A).   { PARSER_STATE->result_value.number = A.number; }

expr(X) ::= expr(A) ADD  expr(B).    { X.number = A.number + B.number; }
//expr(X) ::= expr(A) SUB  expr(B).    { X = A - B; }
//expr(X) ::= expr(A) MUL  expr(B).    { X = A * B; }
//expr(X) ::= expr(A) DIV  expr(B).    { X = A / B; }
//{ if(B != 0){ X = A / B; }else{ printf("divide by zero" ); PARSER_STATE->error = true;} }// end of DIVIDE

expr(X) ::= LPAREN expr(A) RPAREN.   { X.number = A.number; }

expr(X) ::= INT_LITERAL(A).          { X.number = A.number; }

%parse_accept  { PARSER_STATE->error = false; printf("Result : %f\n",PARSER_STATE->result_value.number); printf("The parser has completed successfully.\n"); } // must do PARSER(0, 0); to enter parse_accept
%syntax_error  { PARSER_STATE->error = true; fprintf(stderr, "Syntax Error.\n"); }
%parse_failure { PARSER_STATE->error = true; fprintf(stderr, "Parse failure.\n"); }
