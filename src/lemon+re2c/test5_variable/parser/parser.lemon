// https://sqlite.org/src/doc/trunk/doc/lemon.html
// https://sqlite.org/src/doc/trunk/doc/lemon.html#token_type
// http://souptonuts.sourceforge.net/readme_lemon_tutorial.html
// http://matt.might.net/articles/grammars-bnf-ebnf
// https://www.tutorialspoint.com/compiler_design/compiler_design_syntax_analysis.htm
// https://www.wikiwand.com/en/Shift-reduce_parser
// https://www.wikiwand.com/en/Parsing#/Computational_methods#section_Lookahead

/*
    <> (inequality)                             - use != instead will be : not=
    add (concatenation (strings))               - use + instead
    eq (equality (strings))                     - use == instead
    ne (not equal (strings))                    - use != instead will be : not=
    lt (less than (strings))                    - use < instead
    le (less than or equal to (strings))        - use <= instead
    gt (greater than (strings))                 - use > instead
    ge (greater than or equal to (strings))     - use >= instead
    and (logical and)                           - use && instead mine will be : and
    or (logical or)                             - use || instead mine will be : or
    not (logical not)                           - use ! instead  mine will be : not
*/

%syntax_error  { PARSER_STATE->error = true; fprintf(stderr, "Syntax Error.\n"); }
%parse_failure { PARSER_STATE->error = true; fprintf(stderr, "Parse failure.\n"); }

// must call PARSER(0, 0); to enter %parse_accept
// Formating number of digits after dot %.15lf
%parse_accept  { PARSER_STATE->error = false;
                 printf(" ** Parser Result : %.lf\n",PARSER_STATE->result_value.value_is_a_number);
                 // puts("The parser has completed successfully.");
               }

%include
{
    #include <stdio.h>   // FILE, output on screen
    #include <assert.h>  // 
    #include <stdlib.h>  // malloc, free + os access: open file, read/write file, delete file etc...
    #include <stddef.h>  // size_t
    #include <string.h>  // strlen, strcmp
    #include <stdbool.h> // bool
    #include <math.h>
    
    #include <parser.h>  // All token codes definitions, generated by grammar in lemon
    #include <token.h>   // 

    void * theParser;
    struct _parser_state PARSER_STATE;
    
    void ParseTrace(FILE *TraceFILE, char *str);
    void * ParseAlloc(
        void * (*allocProc)(size_t)             // Function used to allocate memory
    );
    void ParseFree(
        void* parser,                          // The parser to be deleted
        void(*freeProc)(void*)                 // Function used to reclaim memory
    );
    void Parse(
        void * pParser,                        // The parser
        const int pTokentype,                  // The major token code number
        const double pTokenvalue,              // Value associated with a token %token_type { double }
        struct _parser_state * pPARSER_STATE   // %extra_argument parameter
    );
    
    void PARSER_INIT(bool parser_DebugMode){
      theParser = ParseAlloc(malloc);
      if ( parser_DebugMode == true ) ParseTrace(stderr, "[Parser] >> ");
    }
    void PARSER(const struct _Token * pToken){
      
      // Reset variables
      PARSER_STATE.result_value.value_is_a_number = 0;
      
      if ( TK_END_OF_LINE == pToken->type || TK_END_OF_FILE == pToken->type )
      {
        //    PARSER(TK_END_OF_LINE,0); 
        // or PARSER(TK_END_OF_FILE,0);
        Parse(theParser, pToken->type, pToken->value_is_a_number, &PARSER_STATE);
        // must call PARSER(0, 0); to enter %parse_accept
        Parse(theParser, 0, 0, &PARSER_STATE);
      }
      else 
      {
        Parse(theParser, pToken->type, pToken->value_is_a_number, &PARSER_STATE);
      }
    }
    void PARSER_FREE(){
      ParseFree(theParser, free);
    }

} // end %include

%extra_argument  { struct _parser_state * PARSER_STATE }
%token_prefix TK_ // All token codes are integers with #defines that begin with "TK_"
%start_symbol program

%token_type      { double }

// Math order of priority => BIDMAS : Bracket/Parenthesis Indices/Power/Order Divide Multiply Addition Substraction
%nonassoc DEFAULT BREAK RETURN FALLTHROUGH SEMCOL FOR SWITCH IF VARTYPE IDENTIFIER ASSIGN NOT AND OR EQ NE GT GE LT LE.
%left ADD SUB.       // PLUS   MINUS
%left DIV MUL MOD.   // DIVIDE TIMES MODULUS(remainder operator)
%left POS NEG.       // Negation--unary minus
%right EXP.          // 2^3^2 = 2^(3^2) = 512
%left LBRACKET RBRACKET LPAREN RPAREN.

// https://github.com/drifter1/compiler
//
// https://steemit.com/utopian-io/@drifter1/writing-a-simple-compiler-on-my-own-abstract-syntax-tree-management-c-flex-bison
// https://steemit.com/utopian-io/@drifter1/writing-a-simple-compiler-on-my-own-abstract-syntax-tree-structure-c-flex-bison
// https://steemit.com/utopian-io/@drifter1/writing-a-simple-compiler-on-my-own-abstract-syntax-tree-principle-c-flex-bison
// https://efxa.org/2014/05/25/how-to-create-an-abstract-syntax-tree-while-parsing-an-input-stream/
// http://www.cse.iitb.ac.in/grc/intdocs/gcc-implementation-details.html#The-AST/Generic-Data-Structures
//
// http://teampli.net/XPL/ldindex.html
// https://www.cs.cornell.edu/andru/javaspec/2.doc.html#40415
// https://steemit.com/programming/@drifter1/writing-a-simple-compiler-on-my-own-creating-a-grammar-for-our-language
// http://eli-project.sourceforge.net/pascal_html/pascal-.html#s1
// https://www.lysator.liu.se/c/ANSI-C-grammar-y.html
// http://www.quut.com/c/ANSI-C-grammar-y.html
// http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf#page=476
// https://github.com/antlr/grammars-v4/blob/master/c/C.g4

program ::= input.
input ::= .
input ::= input lines.

// This is to terminate with a new line, the grammar dictate when the expression can no longer be reduced.
// Without this PARSER(0, 0); Parse(pParse,0,0) have to be called to signal the end of the input for an expression
lines ::= statements END_OF_LINE|END_OF_FILE.

//statements ::= statements statement|statement.
statements ::= statement.

statement             ::= varDeclaration.
statement             ::= if_statement.
//statement           ::= for_statement.
//statement             ::= switch_statement.
statement             ::= jump_statement.
statement             ::= expression.
varDeclaration        ::= IDENTIFIER ASSIGN VARTYPE ASSIGN expression.  // x=u16=0
varDeclaration        ::= IDENTIFIER ASSIGN VARTYPE.                    // x=u16 // x value = undefined of type u16
varDeclaration        ::= IDENTIFIER ASSIGN expression.                 // x=0   // this is also same for assignment, from undefined to a value.
//assignment          ::= IDENTIFIER ASSIGN expression.                 

// https://steemit.com/utopian-io/@drifter1/writing-a-simple-compiler-on-my-own-action-rules-for-if-else-statements-c-flex-bison
  if_statement        ::=                  IF     bool_expression LBRACKET statement RBRACKET.                             // if expression {true part}
  if_statement        ::=                  IF     bool_expression LBRACKET statement RBRACKET LBRACKET statement RBRACKET. // if expression {true part} { else part }
//else_statement      ::= if_statement     ELSE                   LBRACKET statement RBRACKET. 
//elif_statement      ::= if_statement     ELSEIF bool_expression LBRACKET statement RBRACKET.                             // if expression {true part} expression { elseif part } { else part }
//elif_statement      ::= elif_statement   ELSE                   LBRACKET statement RBRACKET.

//switch_statement      ::= SWITCH expression compound_stmt.
//compound_stmt         ::= expression LBRACKET compound_stmt RBRACKET.
//compound_stmt         ::= DEFAULT LBRACKET compound_stmt RBRACKET.

jump_statement        ::= BREAK expression.
jump_statement        ::= BREAK.
jump_statement        ::= FALLTHROUGH.
jump_statement        ::= RETURN expression.
jump_statement        ::= RETURN.

bool_expression       ::= expression OR expression.
bool_expression       ::= bool_and_expression.
bool_and_expression   ::= expression AND expression.
bool_and_expression   ::= bool_unary_expression.
bool_unary_expression ::= NOT expression.
bool_unary_expression ::= bool_relop_expression.

bool_relop_expression ::= expression relop expression.
relop                 ::= LE|LT|GT|GE|EQ|NE.                            // <=,<,>,>=,==,!=

// Function = https://steemit.com/utopian-io/@drifter1/writing-a-simple-compiler-on-my-own-function-semantics-part-1-c-flex-bison

//     terminals = tokens
// non-terminals = grammar rules (different kinds of nodes in the parse tree)
// A reduction is performed : when a grammar rule is not ambiguous and can be applied to a sequence of one/or more terminals/non-terminals at the top of the stack
// Syntactic Rules  { Semantic Actions }
expression ::= expr(A).             { PARSER_STATE->result_value.value_is_a_number = A; }

expr(X) ::= expr(A) ADD expr(B).    { X = A + B; }
expr(X) ::= expr(A) SUB expr(B).    { X = A - B; }
expr(X) ::= expr(A) MUL expr(B).    { X = A * B; }
expr(X) ::= expr(A) DIV expr(B).    { if(B != 0){ X = A / B;
                                        }else{ puts("/!\\ warning divide by zero" ); X = 0; PARSER_STATE->error = true;} 
                                    } // end of DIVIDE
expr(X) ::= expr(A) MOD expr(B).    { X = fmod(A, B ); } // A % B cannot be done on double
expr(X) ::= expr(A) EXP expr(B).    { X = pow(A, B); } // Exponentiation

expr(X) ::= LPAREN expr(A) RPAREN.  { X = A; }

expr(X) ::= ADD expr(A). [POS]      { X = A; }
expr(X) ::= SUB expr(A). [NEG]      { X = A * -1; } // Negation--unary minus

expr(X) ::= INT_LITERAL(A).         { X = A; }
