// C grammar in Lemon
// https://www.lysator.liu.se/c/ANSI-C-grammar-y.html
// https://www.lysator.liu.se/c/ANSI-C-grammar-l.html
// https://github.com/antlr/grammars-v4/blob/master/c/C.g4
//
////////////////////////////////////////////////////////////////////////

"auto"          {  return(TK_AUTO);            }
"break"         {  return(TK_BREAK);           }
"case"          {  return(TK_CASE);            }
"char"          {  return(TK_CHAR);            }
"const"         {  return(TK_CONST);           }
"continue"      {  return(TK_CONTINUE);        }
"default"       {  return(TK_DEFAULT);         }
"do"            {  return(TK_DO);              }
"double"        {  return(TK_DOUBLE);          }
"else"          {  return(TK_ELSE);            }
"enum"          {  return(TK_ENUM);            }
"extern"        {  return(TK_EXTERN);          }
"float"         {  return(TK_FLOAT);           }
"for"           {  return(TK_FOR);             }
"goto"          {  return(TK_GOTO);            }
"if"            {  return(TK_IF);              }
"int"           {  return(TK_INT);             }
"long"          {  return(TK_LONG);            }
"register"      {  return(TK_REGISTER);        }
"return"        {  return(TK_RETURN);          }
"short"         {  return(TK_SHORT);           }
"signed"        {  return(TK_SIGNED);          }
"sizeof"        {  return(TK_SIZEOF);          }
"static"        {  return(TK_STATIC);          }
"struct"        {  return(TK_STRUCT);          }
"switch"        {  return(TK_SWITCH);          }
"typedef"       {  return(TK_TYPEDEF);         }
"union"         {  return(TK_UNION);           }
"unsigned"      {  return(TK_UNSIGNED);        }
"void"          {  return(TK_VOID);            }
"volatile"      {  return(TK_VOLATILE);        }
"while"         {  return(TK_WHILE);           }

"..."           {  return(TK_ELLIPSIS);        }
">>="           {  return(TK_RIGHT_ASSIGN);    }
"<<="           {  return(TK_LEFT_ASSIGN);     }
"+="            {  return(TK_ADD_ASSIGN);      }
"-="            {  return(TK_SUB_ASSIGN);      }
"*="            {  return(TK_MUL_ASSIGN);      }
"/="            {  return(TK_DIV_ASSIGN);      }
"%="            {  return(TK_MOD_ASSIGN);      }
"&="            {  return(TK_AND_ASSIGN);      }
"^="            {  return(TK_XOR_ASSIGN);      }
"|="            {  return(TK_OR_ASSIGN);       }
">>"            {  return(TK_RIGHT_OP);        }
"<<"            {  return(TK_LEFT_OP);         }
"++"            {  return(TK_INC_OP);          }
"--"            {  return(TK_DEC_OP);          }
"->"            {  return(TK_PTR_OP);          }
"&&"            {  return(TK_AND_OP);          }
"||"            {  return(TK_OR_OP);           }
"<="            {  return(TK_LE_OP);           }
">="            {  return(TK_GE_OP);           }
"=="            {  return(TK_EQ_OP);           }
("!="|"not=")   {  return(TK_NE_OP);           }
";"             {  return(TK_SEMCOL);          }
("{"|"<%")      {  return(TK_LBRACKET);        }
("}"|"%>")      {  return(TK_RBRACKET);        }
","             {  return(TK_COMMA);           }
":"             {  return(TK_COLON);           }
"="             {  return(TK_ASSIGN);          }
"("             {  return(TK_LPAREN);          }
")"             {  return(TK_RPAREN);          }
("["|"<:")      {  return(TK_LSQUAREB);        }
("]"|":>")      {  return(TK_RSQUAREB);        }
"."             {  return(TK_DOT);             }
"&"             {  return(TK_REF);             }
("!"|"not")     {  return(TK_NOT);             }
"~"             {  return(TK_TILDE);           }
"-"             {  return(TK_MINUS);           }
"+"             {  return(TK_PLUS);            }
"*"             {  return(TK_STAR);            }
"/"             {  return(TK_DIV);             }
"%"             {  return(TK_MOD);             }
"<"             {  return(TK_LT);              }
">"             {  return(TK_GT);              }
"^"             {  return(TK_XOR);             }
"|"             {  return(TK_PIPE);            }
"?"             {  return(TK_QUESTION);        }



///////////////////////////////////////////////
        "&" => Tok::Ampersand,
        "!=" => Tok::BangEquals,
        "!~" => Tok::BangTilde,
        ":" => Tok::Colon,
        "::" => Tok::ColonColon,
        "," => Tok::Comma,
        ".." => Tok::DotDot,
        "=" => Tok::Equals,
        "==" => Tok::EqualsEquals,
        "=>" => Tok::EqualsGreaterThanCode(<&'input str>),
        "=>?" => Tok::EqualsGreaterThanQuestionCode(<&'input str>),
        "=>@L" => Tok::EqualsGreaterThanLookahead,
        "=>@R" => Tok::EqualsGreaterThanLookbehind,
        ">" => Tok::GreaterThan,
        "#" => Tok::Hash,
        "#![...]" => Tok::ShebangAttribute(<&'input str>),
        "{" => Tok::LeftBrace,
        "[" => Tok::LeftBracket,
        "(" => Tok::LeftParen,
        "<" => Tok::LessThan,
        "@L" => Tok::Lookahead,
        "@R" => Tok::Lookbehind,
        "->" => Tok::MinusGreaterThan,
        "+" => Tok::Plus,
        "?" => Tok::Question,
        "}" => Tok::RightBrace,
        "]" => Tok::RightBracket,
        ")" => Tok::RightParen,
        ";" => Tok::Semi,
        "*" => Tok::Star,
        "~~" => Tok::TildeTilde,
        "_" => Tok::Underscore,

%union
{
    int   					yint;
    char  					ystr[100];
    struct AstNode_tag   	*stNode;
}

%token <yint> IF ELSE WHILE BREAK RETURN INT REAL CHAR TRUE FALSE
%token <yint> PRINT PRINTLN READ REPEAT TIMES UNLESS AND OR FOR 

%token <ystr> INT_CONST REAL_CONST TEXT CHAR_CONST
%token <ystr> '*' '/' '+' '-'
%token <ystr> INCREASE_SIGN DECREASE_SIGN NOT_SIGN
%token <ystr> PLUS_EQUALS_SIGN MINUS_EQUALS_SIGN TIMES_EQUALS_SIGN DIVIDE_EQUALS_SIGN
%token <ystr> IS_EQUAL IS_NOT_EQUAL IS_LESS_OR_EQUAL IS_GREATER_OR_EQUAL
%token <ystr> '=' '(' ')' '{' '}' ',' ';'
%token <ystr> ID

%type <stNode> Program MethodsList Method Parameters Formals
%type <stNode> Type Body Declarations DeclarationsList Declaration
%type <stNode> Variables Statements Statement Block Assign
%type <stNode> MethodName Location Expression RelationOperator
%type <stNode> AddExpression AddOperator Term MultiplyOperator
%type <stNode> Factor Actuals Arguments Message MoreMessage
%type <stNode> Printable AssignMultiple NestedAssign Code1
%type <stNode> SimpleStatement IncDec RelationExpression
%type <stNode> AndExpression ChangeAssignSymbol ArrayName
