// C grammar in Lemon
// https://www.lysator.liu.se/c/ANSI-C-grammar-y.html
// https://www.lysator.liu.se/c/ANSI-C-grammar-l.html
// https://github.com/antlr/grammars-v4/blob/master/c/C.g4
//
////////////////////////////////////////////////////////////////////////

%include
{
    #include <stdio.h>   // FILE, output on screen
    #include <assert.h>  // 
    #include <stdlib.h>  // malloc, free + os access: open file, read/write file, delete file etc...
    #include <stddef.h>  // size_t
    #include <string.h>  // strlen, strcmp
    #include <stdbool.h> // bool
    #include <math.h>
    
    void * theParser;
    
    void ParseTrace(FILE *TraceFILE, char *str);
    void * ParseAlloc(
        void * (*allocProc)(size_t)             // Function used to allocate memory
    );
    void ParseFree(
        void* parser,                          // The parser to be deleted
        void(*freeProc)(void*)                 // Function used to reclaim memory
    );
    void Parse(
        void * pParser,                        // The parser
        const int pTokentype,                  // The major token code number
        const double pTokenvalue              // Value associated with a token %token_type { double }
    );

}//END %include

%token_prefix TK_ // All token codes are integers with #defines that begin with "TK_"
%start_symbol translation_unit

%left IDENTIFIER CONSTANT STRING_LITERAL SIZEOF
%left PTR_OP INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP
%left AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN
%left SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN
%left XOR_ASSIGN OR_ASSIGN TYPE_NAME
%left TYPEDEF EXTERN STATIC AUTO REGISTER
%left CHAR SHORT INT LONG SIGNED UNSIGNED FLOAT DOUBLE CONST VOLATILE VOID
%left STRUCT UNION ENUM ELLIPSIS
%left CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN

primary_expression
	::= IDENTIFIER
	| CONSTANT
	| STRING_LITERAL
	| LPAREN expression RPAREN
	.

postfix_expression
	::= primary_expression
	| postfix_expression '[' expression ']'
	| postfix_expression LPAREN RPAREN
	| postfix_expression LPAREN argument_expression_list RPAREN
	| postfix_expression '.' IDENTIFIER
	| postfix_expression PTR_OP IDENTIFIER
	| postfix_expression INC_OP
	| postfix_expression DEC_OP
	.

argument_expression_list
	::= assignment_expression
	| argument_expression_list ',' assignment_expression
	.

unary_expression
	::= postfix_expression
	| INC_OP unary_expression
	| DEC_OP unary_expression
	| unary_operator cast_expression
	| SIZEOF unary_expression
	| SIZEOF LPAREN type_name RPAREN
	.

unary_operator
	::= '&'
	| '*'
	| '+'
	| '-'
	| '~'
	| '!'
	.

cast_expression
	::= unary_expression
	| LPAREN type_name RPAREN cast_expression
	.

multiplicative_expression
	::= cast_expression
	| multiplicative_expression '*' cast_expression
	| multiplicative_expression '/' cast_expression
	| multiplicative_expression '%' cast_expression
	.

additive_expression
	::= multiplicative_expression
	| additive_expression '+' multiplicative_expression
	| additive_expression '-' multiplicative_expression
	.

shift_expression
	::= additive_expression
	| shift_expression LEFT_OP additive_expression
	| shift_expression RIGHT_OP additive_expression
	.

relational_expression
	::= shift_expression
	| relational_expression '<' shift_expression
	| relational_expression '>' shift_expression
	| relational_expression LE_OP shift_expression
	| relational_expression GE_OP shift_expression
	.

equality_expression
	::= relational_expression
	| equality_expression EQ_OP relational_expression
	| equality_expression NE_OP relational_expression
	.

and_expression
	::= equality_expression
	| and_expression '&' equality_expression
	.

exclusive_or_expression
	::= and_expression
	| exclusive_or_expression '^' and_expression
	.

inclusive_or_expression
	::= exclusive_or_expression
	| inclusive_or_expression '|' exclusive_or_expression
	.

logical_and_expression
	::= inclusive_or_expression
	| logical_and_expression AND_OP inclusive_or_expression
	.

logical_or_expression
	::= logical_and_expression
	| logical_or_expression OR_OP logical_and_expression
	.

conditional_expression
	::= logical_or_expression
	| logical_or_expression '?' expression ':' conditional_expression
	.

assignment_expression
	::= conditional_expression
	| unary_expression assignment_operator assignment_expression
	.

assignment_operator
	::= '='
	| MUL_ASSIGN
	| DIV_ASSIGN
	| MOD_ASSIGN
	| ADD_ASSIGN
	| SUB_ASSIGN
	| LEFT_ASSIGN
	| RIGHT_ASSIGN
	| AND_ASSIGN
	| XOR_ASSIGN
	| OR_ASSIGN
	.

expression
	::= assignment_expression
	| expression ',' assignment_expression
	.

constant_expression
	::= conditional_expression
	.

declaration
	::= declaration_specifiers SEMCOL
	| declaration_specifiers init_declarator_list SEMCOL
	.

declaration_specifiers
	::= storage_class_specifier
	| storage_class_specifier declaration_specifiers
	| type_specifier
	| type_specifier declaration_specifiers
	| type_qualifier
	| type_qualifier declaration_specifiers
	.

init_declarator_list
	::= init_declarator
	| init_declarator_list ',' init_declarator
	.

init_declarator
	::= declarator
	| declarator '=' initializer
	.

storage_class_specifier
	::= TYPEDEF
	| EXTERN
	| STATIC
	| AUTO
	| REGISTER
	.

type_specifier
	::= VOID
	| CHAR
	| SHORT
	| INT
	| LONG
	| FLOAT
	| DOUBLE
	| SIGNED
	| UNSIGNED
	| struct_or_union_specifier
	| enum_specifier
	| TYPE_NAME
	.

struct_or_union_specifier
	::= struct_or_union IDENTIFIER '{' struct_declaration_list '}'
	| struct_or_union '{' struct_declaration_list '}'
	| struct_or_union IDENTIFIER
	.

struct_or_union
	::= STRUCT
	| UNION
	.

struct_declaration_list
	::= struct_declaration
	| struct_declaration_list struct_declaration
	.

struct_declaration
	::= specifier_qualifier_list struct_declarator_list SEMCOL
	.

specifier_qualifier_list
	::= type_specifier specifier_qualifier_list
	| type_specifier
	| type_qualifier specifier_qualifier_list
	| type_qualifier
	.

struct_declarator_list
	::= struct_declarator
	| struct_declarator_list ',' struct_declarator
	.

struct_declarator
	::= declarator
	| ':' constant_expression
	| declarator ':' constant_expression
	.

enum_specifier
	::= ENUM '{' enumerator_list '}'
	| ENUM IDENTIFIER '{' enumerator_list '}'
	| ENUM IDENTIFIER
	.

enumerator_list
	::= enumerator
	| enumerator_list ',' enumerator
	.

enumerator
	::= IDENTIFIER
	| IDENTIFIER '=' constant_expression
	.

type_qualifier
	::= CONST
	| VOLATILE
	.

declarator
	::= pointer direct_declarator
	| direct_declarator
	.

direct_declarator
	::= IDENTIFIER
	| LPAREN declarator RPAREN
	| direct_declarator '[' constant_expression ']'
	| direct_declarator '[' ']'
	| direct_declarator LPAREN parameter_type_list RPAREN
	| direct_declarator LPAREN identifier_list RPAREN
	| direct_declarator LPAREN RPAREN
	.

pointer
	::= '*'
	| '*' type_qualifier_list
	| '*' pointer
	| '*' type_qualifier_list pointer
	.

type_qualifier_list
	::= type_qualifier
	| type_qualifier_list type_qualifier
	.


parameter_type_list
	::= parameter_list
	| parameter_list ',' ELLIPSIS
	.

parameter_list
	::= parameter_declaration
	| parameter_list ',' parameter_declaration
	.

parameter_declaration
	::= declaration_specifiers declarator
	| declaration_specifiers abstract_declarator
	| declaration_specifiers
	.

identifier_list
	::= IDENTIFIER
	| identifier_list ',' IDENTIFIER
	.

type_name
	::= specifier_qualifier_list
	| specifier_qualifier_list abstract_declarator
	.

abstract_declarator
	::= pointer
	| direct_abstract_declarator
	| pointer direct_abstract_declarator
	.

direct_abstract_declarator
	::= LPAREN abstract_declarator RPAREN
	| '[' ']'
	| '[' constant_expression ']'
	| direct_abstract_declarator '[' ']'
	| direct_abstract_declarator '[' constant_expression ']'
	| LPAREN RPAREN
	| LPAREN parameter_type_list RPAREN
	| direct_abstract_declarator LPAREN RPAREN
	| direct_abstract_declarator LPAREN parameter_type_list RPAREN
	.

initializer
	::= assignment_expression
	| '{' initializer_list '}'
	| '{' initializer_list ',' '}'
	.

initializer_list
	::= initializer
	| initializer_list ',' initializer
	.

statement
	::= labeled_statement
	| compound_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	.

labeled_statement
	::= IDENTIFIER ':' statement
	| CASE constant_expression ':' statement
	| DEFAULT ':' statement
	.

compound_statement
	::= '{' '}'
	| '{' statement_list '}'
	| '{' declaration_list '}'
	| '{' declaration_list statement_list '}'
	.

declaration_list
	::= declaration
	| declaration_list declaration
	.

statement_list
	::= statement
	| statement_list statement
	.

expression_statement ::= SEMCOL.
expression_statement ::= expression SEMCOL.

selection_statement	::= IF LPAREN expression RPAREN statement.
selection_statement	::= IF LPAREN expression RPAREN statement ELSE statement.
selection_statement	::= SWITCH LPAREN expression RPAREN statement.

iteration_statement ::= FOR LPAREN expression_statement expression_statement RPAREN statement.
iteration_statement ::= FOR LPAREN expression_statement expression_statement expression RPAREN statement.

jump_statement ::= GOTO IDENTIFIER SEMCOL.
jump_statement ::= CONTINUE SEMCOL
jump_statement ::= BREAK SEMCOL
jump_statement ::= BREAK expression SEMCOL
jump_statement ::= RETURN SEMCOL
jump_statement ::= RETURN expression SEMCOL

translation_unit
	::= external_declaration
	| translation_unit external_declaration
	.

external_declaration
	::= function_definition
	| declaration
	.

function_definition
	::= declaration_specifiers declarator declaration_list compound_statement
	| declaration_specifiers declarator compound_statement
	| declarator declaration_list compound_statement
	| declarator compound_statement
	.
