//
// C grammar in Lemon
//
// https://www.lysator.liu.se/c/ANSI-C-grammar-y.html
// https://www.lysator.liu.se/c/ANSI-C-grammar-l.html
// https://cs.au.dk/~amoeller/RegAut/JavaBNF.html
// 
// http://www.quut.com/c/ANSI-C-grammar-y.html
// https://github.com/antlr/grammars-v4/blob/master/c/C.g4
// http://www2.cs.tum.edu/projects/cup/examples.php#gast
//
// https://sqlite.org/src/file/tool/lemon.c
// https://sqlite.org/src/doc/trunk/doc/lemon.html
// https://sqlite.org/src/doc/trunk/doc/lemon.html#token_type
// http://souptonuts.sourceforge.net/readme_lemon_tutorial.html
//
////////////////////////////////////////////////////////////////////////

%syntax_error  { PARSER_STATE.error = true; fprintf(stderr, "/!\\ Syntax Error.\n"); }
%parse_failure { PARSER_STATE.error = true; fprintf(stderr, "/!\\ Parse failure.\n"); }

// must call PARSER(0, 0); to enter %parse_accept
// Formating number of digits after dot %.15lf
%parse_accept  { PARSER_STATE.error = false;
                 puts("The parser has completed successfully.");
               }

%include
{
    #include <stdio.h>   // FILE, output on screen
    #include <assert.h>  // 
    #include <stdlib.h>  // malloc, free + os access: open file, read/write file, delete file etc...
    #include <stddef.h>  // size_t
    #include <string.h>  // strlen, strcmp
    #include <stdbool.h> // bool
    #include <math.h>
    
    #include <parser.h>  // All token codes definitions, generated by grammar in lemon
    #include <token.h>   // 
    
    /// Local variables for the parser ///
    void * theParser;
    struct _parser_state PARSER_STATE;
    
    /// Internal Lemon's functions ///
    void ParseTrace(FILE *TraceFILE, char *str);
    void * ParseAlloc(
        void * (*allocProc)(size_t)             // Function used to allocate memory
    );
    void ParseFree(
        void* parser,                          // The parser to be deleted
        void(*freeProc)(void*)                 // Function used to reclaim memory
    );
    void Parse(
        void * pParser,                        // The parser
        const int pTokenID,                    // The major token code number
        const char* pTokenvalue                // Value associated with a token %token_type { const char* }
    );
    
    /// Parser Functions ///
    void PARSER_INIT(bool parser_DebugMode){
      theParser = ParseAlloc(malloc);
      if ( parser_DebugMode == true ) ParseTrace(stderr, "[Parser] >> ");
    }
    void PARSER_FREE(){ ParseFree(theParser, free); }
    
    void PARSER(const struct _scanner_state * pSCANNER_STATE){
      
      // Reset variables to initial values
      PARSER_STATE.error = false;
      
      // Start parsing
      Parse(theParser, pSCANNER_STATE->token_id, pSCANNER_STATE->token_stringvalue);
      
      // If it is end of Line, end the parser.
      // Must 'call PARSER(0, 0);' so parser enter the '%parse_accept'
      if ( TK_END_OF_LINE == pSCANNER_STATE->token_id || TK_END_OF_FILE == pSCANNER_STATE->token_id )
      { Parse(theParser, 0, 0); }
      
    } // END PARSER
    
    void println(const char * pString)
    { printf("GAZGAZ : %s\n",pString); };

} // END %include

%token_prefix TK_               // All token codes are integers with #defines that begin with "TK_"
%token_type { const char* }     // All token values are strings, they will be converted to their value type during semantic analysis.
%start_symbol program           // First grammar rule to start with

%nonassoc IDENTIFIER NUMBER_LITERAL STRING_LITERAL QUOTE SEMCOL.
%nonassoc IF ELSE TRUE FALSE FOR SWITCH RETURN BREAK CONTINUE FALLTHROUGH DEFAULT.
%nonassoc EQ NE GT GE LT LE.            // == not= > >= < <=

%nonassoc DOT COLON QUESTION LSQUAREB RSQUAREB ELLIPSIS.

%left PTR_OP INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP.
%left AND_OP OR_OP STAR_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN.
%left SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN.
%left XOR_ASSIGN OR_ASSIGN TYPE_NAME.


%left AND.
%left OR.
// Math order of priority => BIDMAS : Bracket/Parenthesis Indices/Power/Order Divide Multiply Addition Substraction
%left ADD SUB.                          // PLUS MINUS
%left MUL DIV MOD.                      // DIVIDE TIMES MODULUS(remainder operator)
%left POS NEG.                          // Negation--unary minus
%left LBRACKET RBRACKET LPAREN RPAREN.  // { } ( )
%right EXP NOT.                         // 2^3^2 = 2^(3^2) = 512


/************************************************************************

                    ยง THE LEMON GRAMMAR RULES ยง
________________________________________________________________________

* Grammar rule start with lowercase or are all lowercase

* no compund statement ! one grammar rule is one condition, no multi option like in regular expression
Example : jump_statement        ::= BREAK expression|BREAK.
Will become
          jump_statement        ::= BREAK expression.
          jump_statement        ::= BREAK.

1.Tokens are consumed one-by-one and added to a stack
2.A reduction is performed : when a grammar rule is not ambiguous and can be applied to a sequence of one/or more terminals/non-terminals at the top of the stack
3.Goal is to reduce input to a single non-terminal


    terminals = tokens
non-terminals = names of other grammar rules (different kinds of nodes in the parse tree)


non-terminals => lower case
    terminals => UPPER CASE
________________________________________________________________________
************************************************************************/


//
program ::= input.
input ::= .
input ::= input lines.
lines ::= block_statement END_OF_LINE|END_OF_FILE.                     { println("lines ::= translation_unit END_OF_LINE|END_OF_FILE."); }

block_statement ::= LBRACKET RBRACKET.
block_statement ::= LBRACKET statement_list RBRACKET.

statement_list ::= statement.
statement_list ::= statement_list statement.

statement ::= variable.
statement ::= ifstmt.
//statement ::= forstmt.
//statement ::= switchstmt.
//statement ::= proc_definition.
statement ::= proc_call.


//=====================================================================//
//////////////////////////////////  EXPRESSIONS  ///////////////////////
//=====================================================================//

expression  ::= expression COMMA opAssign.
expression  ::= opAssign.

opAssign    ::= opOr ASSIGN       opAssign.
opAssign    ::= opOr ADD_ASSIGN   opAssign.
opAssign    ::= opOr SUB_ASSIGN   opAssign.
opAssign    ::= opOr MUL_ASSIGN   opAssign.
opAssign    ::= opOr DIV_ASSIGN   opAssign.
opAssign    ::= opOr XOR_ASSIGN   opAssign.
opAssign    ::= opOr AND_ASSIGN   opAssign.
opAssign    ::= opOr OR_ASSIGN    opAssign.
opAssign    ::= opOr RIGHT_ASSIGN opAssign.
opAssign    ::= opOr LEFT_ASSIGN  opAssign.
opAssign    ::= opOr.

opOr        ::= opOr OR_OP opAnd.
opOr        ::= opAnd.

opAnd       ::= opAnd AND_OP opBinOR.
opAnd       ::= opBinOR.

opBinOR     ::= opBinOR PIPE opBinXOR.
opBinOR     ::= opBinXOR.

opBinXOR    ::= opBinXOR XOR opBinAND.
opBinXOR    ::= opBinAND.

opBinAND    ::= opBinAND REF opEquate.
opBinAND    ::= opEquate.

opEquate    ::= opEquate EQ_OP opCompare.
opEquate    ::= opEquate NE_OP opCompare.
opEquate    ::= opCompare.

opCompare   ::= opCompare LT    opShift.
opCompare   ::= opCompare GT    opShift.
opCompare   ::= opCompare LE_OP opShift.
opCompare   ::= opCompare GE_OP opShift.
opCompare   ::= opShift.

opShift     ::= opShift LEFT_OP  opAdd.
opShift     ::= opShift RIGHT_OP opAdd.
opShift     ::= opAdd.

opAdd       ::= opAdd PLUS  opMult.
opAdd       ::= opAdd MINUS opMult.
opAdd       ::= opMult.

opMult      ::= opMult STAR opUnary.
opMult      ::= opMult DIV  opUnary.
opMult      ::= opMult MOD  opUnary.
opMult      ::= opUnary.

opUnary     ::= NOT   opUnary.
opUnary     ::= TILDE opUnary.
opUnary     ::= MINUS opUnary.
opUnary     ::= value.

value       ::= OCTLITERAL.
value       ::= HEXLITERAL.
value       ::= NUMBERLITERAL.
value       ::= QUOTE STRINGLITERAL QUOTE.
value       ::= CHARLITERAL.
value       ::= FLOATLITERAL.
value       ::= IDENTIFIER LPAREN expression RPAREN.
value       ::= IDENTIFIER LPAREN RPAREN.
value       ::= IDENTIFIER.
value       ::= LPAREN expression RPAREN.
value       ::= boolean_literal.
boolean_literal     ::= TRUE |FALSE.

//=======================
//       VARIABLES      //
//////////////////////////

variable ::= variable_declaration.
variable ::= variable_assignment.

type                    ::= U8 |U16 |U32 |U64 |U128 |I8 |I16 |I32 |I64 |I128 |F16 |F32 |F64.
identifier_list         ::= IDENTIFIER.
identifier_list         ::= identifier_list COMMA IDENTIFIER.

variable_declaration    ::= identifier_list ASSIGN type.                        // var=u16      i,j,k=u16
variable_declaration    ::= identifier_list ASSIGN type ASSIGN expression.      // var=u16=15   i,j,k=u16=15
variable_declaration    ::= identifier_list ASSIGN QUOTE STRING_LITERAL QUOTE.  // var="string" i,j,k="string"
variable_declaration    ::= identifier_list ASSIGN boolean_literal.             // var=true i,j,k=false

// existing var change value var=17
variable_assignment     ::= identifier_list ASSIGN identifier_list.             // i,j,k=a,b,c

// expression_list      ::= expression.
// expression_list      ::= expression_list COMMA expression.
// variable_assignment  ::= identifier_list ASSIGN expression_list.           // i,j,k=1,2,3 or i,j,k=1*2,2*2,3*3



//=======================
//    IF STATEMENT      //
//////////////////////////

ifstmt                  ::= IF expression LBRACKET block_statement RBRACKET.
ifstmt                  ::= IF expression LBRACKET block_statement RBRACKET ELSE LBRACKET block_statement RBRACKET.



//=======================
//        FOR LOOP      //
//////////////////////////

//forstmt               ::= FOR for_init SEMCOL expression SEMCOL for_update for_block_statement.
//for_init              ::= expression.
//for_init              ::= variable_declaration.
//for_update            ::= expression.
//for_block_statement   ::= block_statement.
//for_block_statement   ::= for_jump_statement.
//for_jump_statement    ::= BREAK.
//for_jump_statement    ::= BREAK expression.
//for_jump_statement    ::= CONTINUE.



//=======================
//     SWITCH CASE      //
//////////////////////////

//switchstmt            ::= SWITCH expression LBRACKET switch_block RBRACKET.
//switch_block          ::= expression LBRACKET switch_case_block RBRACKET.
//switch_block          ::= DEFAULT    LBRACKET statement RBRACKET.         // DEFAULT {}
//switch_case_block     ::= FALLTHROUGH.
//switch_case_block     ::= statement.



//=======================
//       PROCEDURE      //
//////////////////////////

//variable_declaration_list ::= variable_declaration.
//variable_declaration_list ::= variable_declaration_list COMMA variable_declaration.

//proc_definition       ::= IDENTIFIER LPAREN RPAREN proc_statement.       // proc_add() { ... }
//proc_definition       ::= IDENTIFIER LPAREN variable_declaration_list RPAREN proc_statement. // proc_add(x,y,z) { ... }
//proc_statement        ::= block_statement.
//proc_statement        ::= proc_return.
//proc_return           ::= RETURN.                                         { println("proc_return ::= RETURN."); }
//proc_return           ::= RETURN expression.                              { println("proc_return ::= RETURN expression."); }

proc_call             ::= IDENTIFIER LPAREN RPAREN.                            // proc_add()
//proc_call             ::= IDENTIFIER LPAREN variable_declaration_list RPAREN.  // proc_add(x,y,z)

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
