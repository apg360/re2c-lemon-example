// C grammar in Lemon
// https://www.lysator.liu.se/c/ANSI-C-grammar-y.html
// https://www.lysator.liu.se/c/ANSI-C-grammar-l.html
// https://cs.au.dk/~amoeller/RegAut/JavaBNF.html
// 
// https://github.com/antlr/grammars-v4/blob/master/c/C.g4
// http://www2.cs.tum.edu/projects/cup/examples.php#gast
//
// https://sqlite.org/src/file/tool/lemon.c
// https://sqlite.org/src/doc/trunk/doc/lemon.html
// https://sqlite.org/src/doc/trunk/doc/lemon.html#token_type
// http://souptonuts.sourceforge.net/readme_lemon_tutorial.html
//
////////////////////////////////////////////////////////////////////////
/*
   
   C grammar in EBNF
   https://www.lysator.liu.se/c/ANSI-C-grammar-y.html
   http://www.quut.com/c/ANSI-C-grammar-y.html
   https://www2.cs.arizona.edu/~debray/Teaching/CSc453/DOCS/cminusminusspec.html
   https://cs.wmich.edu/~gupta/teaching/cs4850/sumII06/The%20syntax%20of%20C%20in%20Backus-Naur%20form.htm
   
   https://github.com/Thanasis1101/Compiler-for-custom-language/blob/master/Source%20Code/Compiler/Semantics.c
   https://github.com/Thanasis1101/Compiler-for-custom-language
   https://github.com/gwenn/lemon-rs/blob/master/examples/simple.y
   https://github.com/drifter1/compiler
   http://matt.might.net/articles/grammars-bnf-ebnf
   https://www.tutorialspoint.com/compiler_design/compiler_design_syntax_analysis.htm
   https://www.wikiwand.com/en/Shift-reduce_parser
   https://www.wikiwand.com/en/Parsing#/Computational_methods#section_Lookahead
   
   https://steemit.com/utopian-io/@drifter1/writing-a-simple-compiler-on-my-own-abstract-syntax-tree-management-c-flex-bison
   https://steemit.com/utopian-io/@drifter1/writing-a-simple-compiler-on-my-own-abstract-syntax-tree-structure-c-flex-bison
   https://steemit.com/utopian-io/@drifter1/writing-a-simple-compiler-on-my-own-abstract-syntax-tree-principle-c-flex-bison
   https://efxa.org/2014/05/25/how-to-create-an-abstract-syntax-tree-while-parsing-an-input-stream/
   http://www.cse.iitb.ac.in/grc/intdocs/gcc-implementation-details.html#The-AST/Generic-Data-Structures
  
   http://teampli.net/XPL/ldindex.html
   https://www.cs.cornell.edu/andru/javaspec/2.doc.html#40415
   https://steemit.com/programming/@drifter1/writing-a-simple-compiler-on-my-own-creating-a-grammar-for-our-language
   http://eli-project.sourceforge.net/pascal_html/pascal-.html#s1
   http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf#page=476
   https://github.com/antlr/grammars-v4/blob/master/c/C.g4
   https://www.cs.rochester.edu/u/scott/courses/173/notes/05_grammars
*/
////////////////////////////////////////////////////////////////////////


%syntax_error  { PARSER_STATE.error = true; fprintf(stderr, "/!\\ Syntax Error.\n"); }
%parse_failure { PARSER_STATE.error = true; fprintf(stderr, "/!\\ Parse failure.\n"); }

// must call PARSER(0, 0); to enter %parse_accept
// Formating number of digits after dot %.15lf
%parse_accept  { PARSER_STATE.error = false;
                 puts("The parser has completed successfully.");
               }

%include
{
    #include <stdio.h>   // FILE, output on screen
    #include <assert.h>  // 
    #include <stdlib.h>  // malloc, free + os access: open file, read/write file, delete file etc...
    #include <stddef.h>  // size_t
    #include <string.h>  // strlen, strcmp
    #include <stdbool.h> // bool
    #include <math.h>
    
    #include <parser.h>  // All token codes definitions, generated by grammar in lemon
    #include <token.h>   // 
    
    /// Local variables for the parser ///
    void * theParser;
    struct _parser_state PARSER_STATE;
    
    /// Internal Lemon's functions ///
    void ParseTrace(FILE *TraceFILE, char *str);
    void * ParseAlloc(
        void * (*allocProc)(size_t)             // Function used to allocate memory
    );
    void ParseFree(
        void* parser,                          // The parser to be deleted
        void(*freeProc)(void*)                 // Function used to reclaim memory
    );
    void Parse(
        void * pParser,                        // The parser
        const int pTokenID,                    // The major token code number
        const char* pTokenvalue                // Value associated with a token %token_type { const char* }
    );
    
    /// Parser Functions ///
    void PARSER_INIT(bool parser_DebugMode){
      theParser = ParseAlloc(malloc);
      if ( parser_DebugMode == true ) ParseTrace(stderr, "[Parser] >> ");
    }
    void PARSER_FREE(){ ParseFree(theParser, free); }
    
    void PARSER(const struct _scanner_state * pSCANNER_STATE){
      
      // Reset variables to initial values
      PARSER_STATE.error = false;
      
      // Start parsing
      Parse(theParser, pSCANNER_STATE->token_id, pSCANNER_STATE->token_stringvalue);
      
      // If it is end of Line, end the parser.
      // Must 'call PARSER(0, 0);' so parser enter the '%parse_accept'
      if ( TK_END_OF_LINE == pSCANNER_STATE->token_id || TK_END_OF_FILE == pSCANNER_STATE->token_id )
      { Parse(theParser, 0, 0); }
      
    } // END PARSER
    
    void println(const char * pString)
    { printf("GAZGAZ : %s\n",pString); };

} // END %include

%token_prefix TK_               // All token codes are integers with #defines that begin with "TK_"
%token_type { const char* }     // All token values are strings, they will be converted to their value type during semantic analysis.
%start_symbol program           // First grammar rule to start with

/*
---------
<> (inequality)                             - use != instead        will be : not=
add (concatenation (strings))               - use +  instead
eq (equality (strings))                     - use == instead
ne (not equal (strings))                    - use != instead        will be : not= or not==
lt (less than (strings))                    - use <  instead
le (less than or equal to (strings))        - use <= instead
gt (greater than (strings))                 - use >  instead
ge (greater than or equal to (strings))     - use >= instead
and (logical and)                           - use && instead        will be : and
or (logical or)                             - use || instead        will be : or
not (logical not)                           - use !  instead        will be : not
---------
%nonassoc IDENTIFIER NUMBER_LITERAL STRING_LITERAL TRUE FALSE QUOTE.
%nonassoc TYPEDEF EXTERN STATIC AUTO REGISTER.
%nonassoc IF ELSE TRUE FALSE FOR SWITCH RETURN BREAK CONTINUE FALLTHROUGH DEFAULT VARTYPE.
%left PTR_OP INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP.
%left AND_OP OR_OP STAR_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN.
%left SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN.
%left XOR_ASSIGN OR_ASSIGN TYPE_NAME.
---------
*/


%nonassoc DEFAULT BREAK RETURN FALLTHROUGH SEMCOL FOR SWITCH IF VARTYPE IDENTIFIER ASSIGN.
%left AND.
%left OR.
%nonassoc EQ NE GT GE LT LE.            // == not= > >= < <=
// Math order of priority => BIDMAS : Bracket/Parenthesis Indices/Power/Order Divide Multiply Addition Substraction
%left ADD SUB.                          // PLUS MINUS
%left MUL DIV MOD.                      // DIVIDE TIMES MODULUS(remainder operator)
%left POS NEG.                          // Negation--unary minus
%left LBRACKET RBRACKET LPAREN RPAREN.  // { } ( )
%right EXP NOT.                         // 2^3^2 = 2^(3^2) = 512


/*
    ยง HOW IS THE LEMON GRAMMAR ยง

no compund statement ! one grammar rule is one condition, no multi option like in regular expression
Example : jump_statement        ::= BREAK expression|BREAK.
Will become
          jump_statement        ::= BREAK expression.
          jump_statement        ::= BREAK.

1.Tokens are consumed one-by-one and added to a stack
2.A reduction is performed : when a grammar rule is not ambiguous and can be applied to a sequence of one/or more terminals/non-terminals at the top of the stack
3.Goal is to reduce input to a single non-terminal


    terminals = tokens
non-terminals = names of other grammar rules (different kinds of nodes in the parse tree)


non-terminals => lower case
    terminals => UPPER CASE
*/

//
program ::= input.
input ::= .
input ::= input lines.
lines ::= block_statement END_OF_LINE|END_OF_FILE.                     { println("lines ::= translation_unit END_OF_LINE|END_OF_FILE."); }

/*

boolean_literal     ::= true | false.
//type     ::= u8 | u16 | u32 | u64 | u128 | i8 | i16 | i32 | i64 | i128 | f16 | f32 | f64.
assignment_operator ::= ASSIGN|STAR_ASSIGN|DIV_ASSIGN|MOD_ASSIGN|ADD_ASSIGN|SUB_ASSIGN   // = | *= | /= | %= | += | -=
                    |LEFT_ASSIGN|RIGHT_ASSIGN|AND_ASSIGN|XOR_ASSIGN|OR_ASSIGN.           // <<= | >>= | &= | ^= | |=
unary_operator  ::= PLUS|MINUS|TILDE|NOT.

identifier_list ::= IDENTIFIER.
identifier_list ::= identifier_list COMMA IDENTIFIER.
argument_list   ::= expression.
argument_list   ::= argument_list COMMA expression.

block_statement ::= LBRACKET RBRACKET.
block_statement ::= LBRACKET statement_list RBRACKET.

statement_list ::= statement.
statement_list ::= statement_list statement.

statement ::= variable.
statement ::= ifstmt.
statement ::= forstmt.
statement ::= switchstmt.
statement ::= proc_definition.
statement ::= proc_call.

///////////////
// VARIABLES //
///////////////
variable ::= variable_declaration.
variable ::= variable_assignment.

variable_declaration ::= IDENTIFIER ASSIGN type.                        // var=u16
variable_declaration ::= IDENTIFIER ASSIGN type ASSIGN NUMBER_LITERAL.  // var=u16=15
variable_declaration ::= IDENTIFIER ASSIGN QUOTE STRING_LITERAL QUOTE.  // var="string"
variable_declaration ::= IDENTIFIER ASSIGN boolean_literal.             // var=true + var=false

variable_assignment  ::= IDENTIFIER ASSIGN expression.                  // existing var change value var=17
variable_assignment  ::= identifier_list ASSIGN identifier_list.        // i,j,k=a,b,c
//variable_assignment  ::= identifier_list ASSIGN expression_list.      // i,j,k=1,2,3 or i,j,k=1*2,2*2,3*3

//////////////////
// IF STATEMENT //
//////////////////
ifstmt              ::= IF expression LBRACKET block_statement RBRACKET.
ifstmt              ::= IF expression LBRACKET block_statement RBRACKET ELSE LBRACKET block_statement RBRACKET.

//////////////
// FOR LOOP //
//////////////
//forstmt             ::= FOR for_init SEMCOL expression SEMCOL for_update for_block_statement.
//for_init            ::= expression | variable_declaration.
//for_update          ::= expression.
//for_block_statement ::= block_statement.
//for_block_statement ::= for_jump_statement.
//for_jump_statement  ::= BREAK.
//for_jump_statement  ::= BREAK primary_expression.
//for_jump_statement  ::= CONTINUE.

/////////////////
// SWITCH CASE //
/////////////////
//switchstmt          ::= SWITCH expression LBRACKET switch_block RBRACKET.
//switch_block        ::= expression LBRACKET switch_case_block RBRACKET.
//switch_block        ::= DEFAULT    LBRACKET statement RBRACKET.         // DEFAULT {}
//switch_case_block   ::= FALLTHROUGH.
//switch_case_block   ::= statement.

///////////////
// PROCEDURE //
///////////////
proc_definition     ::= IDENTIFIER LPAREN RPAREN proc_statement.       // proc_add() { ... }
proc_definition     ::= IDENTIFIER LPAREN argument_list RPAREN proc_statement. // proc_add(x,y,z) { ... }
proc_statement      ::= block_statement.
proc_statement      ::= proc_return.
proc_return         ::= RETURN.                                         { println("proc_return ::= RETURN."); }
proc_return         ::= RETURN expression.                              { println("proc_return ::= RETURN expression."); }

proc_call           ::= IDENTIFIER LPAREN RPAREN.                       // proc_add()
proc_call           ::= IDENTIFIER LPAREN argument_list RPAREN.         // proc_add(x,y,z)

////////////////////////////////////////////////////////////////////////
//////////////////////////////////  EXPRESSIONS  ///////////////////////
////////////////////////////////////////////////////////////////////////

expression ::= conditional_expression | variable_assignment

conditional_expression ::= conditional_or_expression.
conditional_or_expression ::= conditional_and_expression.
conditional_or_expression ::= conditional_or_expression || conditional_and_expression.
conditional_and_expression ::= inclusive_or_expression.
conditional_and_expression ::= conditional_and_expression && inclusive_or_expression.

inclusive_or_expression ::= exclusive_or_expression.
inclusive_or_expression ::= inclusive_or_expression exclusive_or_expression.

exclusive_or_expression ::= and_expression.
exclusive_or_expression ::= exclusive_or_expression ^ and_expression.

and_expression ::= equality_expression.
and_expression ::= and_expression & equality_expression.

equality_expression ::= relational_expression.
equality_expression ::= equality_expression == relational_expression.
equality_expression ::= equality_expression not= relational_expression.

relational_expression ::= shift_expression.
relational_expression ::= relational_expression < shift_expression.
relational_expression ::= relational_expression > shift_expression.
relational_expression ::= relational_expression <= shift_expression.
relational_expression ::= relational_expression >= shift_expression.

shift_expression ::= additive_expression.
shift_expression ::= shift_expression << additive_expression.
shift_expression ::= shift_expression >> additive_expression.
shift_expression ::= shift_expression >>> additive_expression.

additive_expression ::= multiplicative_expression.
additive_expression ::= additive_expression + multiplicative_expression.
additive_expression ::= additive_expression - multiplicative_expression.

multiplicative_expression ::= unary_expression.
multiplicative_expression ::= multiplicative_expression * unary_expression.
multiplicative_expression ::= multiplicative_expression / unary_expression.
multiplicative_expression ::= multiplicative_expression % unary_expression.

// https://en.wikipedia.org/wiki/Unary_operation
unary_expression ::= primary.
unary_expression ::= + unary_expression.
unary_expression ::= - unary_expression.
unary_expression ::= ~ unary_expression.
unary_expression ::= NOT unary_expression.
primary ::= IDENTIFIER | ( expression ).

*/

statement_list ::= statement.
statement_list ::= statement_list statement.
statement ::= compound_statement.
statement ::= expression_statement. //UNARY OPERATIONS
statement ::= selection_statement.
statement ::= forloop_iteration_statement.
statement ::= jump_statement.

compound_statement ::= LBRACKET RBRACKET.
compound_statement ::= LBRACKET statement_list RBRACKET.
compound_statement ::= LBRACKET declaration_list RBRACKET.
compound_statement ::= LBRACKET declaration_list statement_list RBRACKET.

primary_expression ::= IDENTIFIER.
primary_expression ::= CONSTANT.
primary_expression ::= STRING_LITERAL.
primary_expression ::= LPAREN expression RPAREN. //UNARY OPERATIONS





////////////////////////////////////////////////////////////////////////////////







<Expression>   ::= <Expression> '>'  <Add Exp> 
                 | <Expression> '<'  <Add Exp> 
                 | <Expression> '<=' <Add Exp> 
                 | <Expression> '>=' <Add Exp>
                 | <Expression> '==' <Add Exp>
                 | <Expression> '<>' <Add Exp>
                 | <Add Exp> 

<Add Exp>      ::= <Add Exp> '+' <Mult Exp>
                 | <Add Exp> '-' <Mult Exp>
                 | <Add Exp> '&' <Mult Exp>
                 | <Mult Exp> 

<Mult Exp>    ::= <Mult Exp> '*' <Negate Exp> 
                | <Mult Exp> '/' <Negate Exp> 
                | <Negate Exp> 

<Negate Exp>  ::= '-' <Value> 
                | <Value> 

<Value>       ::= ID           
                | StringLiteral
                | NumberLiteral
                | '(' <Expression> ')'



////////////////////////////////////////////////////////////////////////////////



//UNARY OPERATIONS

argument_expression_list ::= assignment_expression.
argument_expression_list ::= argument_expression_list COMMA assignment_expression.
expression_statement ::= SEMCOL.
expression_statement ::= expression SEMCOL.
expression ::= assignment_expression.
expression ::= expression COMMA assignment_expression.

assignment_expression ::= unary_expression assignment_operator assignment_expression. // --var += var++

//multiplicative_expression ::= unary_expression.
//multiplicative_expression ::= multiplicative_expression STAR unary_expression.
//multiplicative_expression ::= multiplicative_expression DIV unary_expression.
//multiplicative_expression ::= multiplicative_expression MOD unary_expression.


//additive_expression ::= multiplicative_expression.
//additive_expression ::= additive_expression PLUS multiplicative_expression.
//additive_expression ::= additive_expression MINUS multiplicative_expression.


//shift_expression ::= additive_expression.
//shift_expression ::= shift_expression LEFT_OP additive_expression.
//shift_expression ::= shift_expression RIGHT_OP additive_expression.


//relational_expression ::= shift_expression.
//relational_expression ::= relational_expression LT shift_expression.
//relational_expression ::= relational_expression GT shift_expression.
//relational_expression ::= relational_expression LE_OP shift_expression.
//relational_expression ::= relational_expression GE_OP shift_expression.


//equality_expression ::= relational_expression.
//equality_expression ::= equality_expression EQ_OP relational_expression.
//equality_expression ::= equality_expression NE_OP relational_expression.


//and_expression ::= equality_expression.
//and_expression ::= and_expression REF equality_expression.


//exclusive_or_expression ::= and_expression.
//exclusive_or_expression ::= exclusive_or_expression XOR and_expression.


//inclusive_or_expression ::= exclusive_or_expression.
//inclusive_or_expression ::= inclusive_or_expression PIPE exclusive_or_expression.


//logical_and_expression ::= inclusive_or_expression.
//logical_and_expression ::= logical_and_expression AND_OP inclusive_or_expression.


//logical_or_expression ::= logical_and_expression.
//logical_or_expression ::= logical_or_expression OR_OP logical_and_expression.

/*
//https://www.essaytaste.com/solved-consider-following-ebnf-grammar-simple-programming-language-program-s-statemt-statemt-assn-q35399240-2/
program  ::= S {statemt}
statemt  ::= assnmt | ifstmt | do | inout | progcall
assnmt   ::= ident ~ exprsn ;
ifstmt   ::= I comprsn @ {statemt} [% {statemt}] &
do       ::= D {statemt} U comprsn E
inout    ::= iosym ident {, ident } ;
iosym    ::= R | O
progcall ::= C program G
comprsn  ::= ( oprnd opratr oprnd )
exprsn   ::= factor {+ factor}
factor   ::= oprnd {* oprnd}
oprnd    ::= integer | ident | bool | ( exprsn )
opratr   ::= < | = | > | ! | ^
ident    ::= letter {char}
char     ::= letter | digit
integer  ::= digit {digit}
letter   ::= W | X | Y | Z
digit    ::= 0 | 1
bool     ::= T | F
*/


!=======================================================

<Decls> ::= <Decl> <Decls>
          |

<Decl>  ::= <Func Decl>
          | <Func Proto>
          | <Struct Decl>
          | <Union Decl>
          | <Enum Decl>
          | <Var Decl>    
          | <Typedef Decl>
              
! ===================================================================
! Function  Declaration
! ===================================================================

<Func Proto> ::= <Func ID> '(' <Types>  ')' ';'
               | <Func ID> '(' <Params> ')' ';'
               | <Func ID> '(' ')' ';'

<Func Decl>  ::= <Func ID> '(' <Params>  ')' <Block>
               | <Func ID> '(' <Id List> ')' <Struct Def> <Block>
               | <Func ID> '(' ')' <Block>


<Params>     ::= <Param> ',' <Params>
               | <Param>
               
<Param>      ::= const <Type> ID
               |       <Type> ID
               
<Types>      ::= <Type>  ',' <Types>
               | <Type> 
   
<Id List>    ::= Id ',' <Id List>
               | Id

<Func ID>    ::= <Type> ID
               | ID

! ===================================================================
! Type Declaration
! ===================================================================

<Typedef Decl> ::= typedef <Type> ID ';'

<Struct Decl>  ::= struct Id '{' <Struct Def> '}'  ';' 

<Union Decl>   ::= union Id '{' <Struct Def> '}'  ';' 


<Struct Def>   ::= <Var Decl> <Struct Def>
                 | <Var Decl>

! ===================================================================
! Variable Declaration
! ===================================================================

<Var Decl>     ::= <Mod> <Type> <Var> <Var List>  ';'
                 |       <Type> <Var> <Var List>  ';'
                 | <Mod>        <Var> <Var List>  ';'
             
<Var>      ::= ID <Array>
             | ID <Array> '=' <Op If> 

<Array>    ::= '[' <Expr> ']'
             | '[' ']'
             |
             
<Var List> ::=  ',' <Var Item> <Var List>
             | 

<Var Item> ::= <Pointers> <Var>

             
<Mod>      ::= extern 
             | static
             | register
             | auto
             | volatile
             | const   

! ===================================================================
! Enumerations
! ===================================================================

<Enum Decl>    ::= enum Id '{' <Enum Def> '}'  ';'
 
<Enum Def>     ::= <Enum Val> ',' <Enum Def>
                 | <Enum Val>

<Enum Val>     ::= Id
                 | Id '=' OctLiteral
                 | Id '=' HexLiteral
                 | Id '=' DecLiteral  


! ===================================================================
! Types
! ===================================================================

<Type>     ::= <Base> <Pointers> 

<Base>     ::= <Sign> <Scalar>
             | struct Id 
             | struct '{' <Struct Def> '}' 
             | union Id
             | union '{' <Struct Def> '}' 
             | enum Id  


<Sign>     ::= signed 
             | unsigned
             |

<Scalar>   ::= char
             | int
             | short
             | long
             | short int
             | long int
             | float
             | double
             | void

<Pointers> ::= '*' <Pointers>
             |

! ===================================================================
! Statements
! ===================================================================

<Stm>        ::= <Var Decl>
               | Id ':'                            !Label
               | if '(' <Expr> ')' <Stm>          
               | if '(' <Expr> ')' <Then Stm> else <Stm>         
               | while '(' <Expr> ')' <Stm> 
               | for '(' <Arg> ';' <Arg> ';' <Arg> ')' <Stm>
               | <Normal Stm>

<Then Stm>   ::= if '(' <Expr> ')' <Then Stm> else <Then Stm> 
               | while '(' <Expr> ')' <Then Stm> 
               | for '(' <Arg> ';' <Arg> ';' <Arg> ')' <Then Stm>
               | <Normal Stm>

<Normal Stm> ::= do <Stm> while '(' <Expr> ')'
               | switch '(' <Expr> ')' '{' <Case Stms> '}'
               | <Block>
               | <Expr> ';'               
               | goto Id ';'
               | break ';'
               | continue ';'
               | return <Expr> ';'
               | ';'              !Null statement


<Arg>       ::= <Expr> 
              | 

<Case Stms> ::= case <Value> ':' <Stm List> <Case Stms>
              | default ':' <Stm List>                  
              |

<Block>     ::= '{' <Stm List> '}' 

<Stm List>  ::=  <Stm> <Stm List> 
              | 


! ===================================================================
! Here begins the C's 15 levels of operator precedence.
! ===================================================================

<Expr>       ::= <Expr> ',' <Op Assign>   
               | <Op Assign>

<Op Assign>  ::= <Op If> '='   <Op Assign>
               | <Op If> '+='  <Op Assign>
               | <Op If> '-='  <Op Assign>
               | <Op If> '*='  <Op Assign>
               | <Op If> '/='  <Op Assign>
               | <Op If> '^='  <Op Assign>
               | <Op If> '&='  <Op Assign>
               | <Op If> '|='  <Op Assign>
               | <Op If> '>>=' <Op Assign>
               | <Op If> '<<=' <Op Assign>
               | <Op If>

<Op If>      ::= <Op Or> '?' <Op If> ':' <Op If>
               | <Op Or>

<Op Or>      ::= <Op Or> '||' <Op And>
               | <Op And>

<Op And>     ::= <Op And> '&&' <Op BinOR>
               | <Op BinOR>

<Op BinOR>   ::= <Op BinOr> '|' <Op BinXOR>
               | <Op BinXOR>

<Op BinXOR>  ::= <Op BinXOR> '^' <Op BinAND>
               | <Op BinAND>

<Op BinAND>  ::= <Op BinAND> '&' <Op Equate>
               | <Op Equate>

<Op Equate>  ::= <Op Equate> '==' <Op Compare>
               | <Op Equate> '!=' <Op Compare>
               | <Op Compare>

<Op Compare> ::= <Op Compare> '<'  <Op Shift>
               | <Op Compare> '>'  <Op Shift>
               | <Op Compare> '<=' <Op Shift>
               | <Op Compare> '>=' <Op Shift>
               | <Op Shift>

<Op Shift>   ::= <Op Shift> '<<' <Op Add>
               | <Op Shift> '>>' <Op Add>
               | <Op Add>

<Op Add>     ::= <Op Add> '+' <Op Mult>
               | <Op Add> '-' <Op Mult>
               | <Op Mult>

<Op Mult>    ::= <Op Mult> '*' <Op Unary>
               | <Op Mult> '/' <Op Unary>
               | <Op Mult> '%' <Op Unary>
               | <Op Unary>

<Op Unary>   ::= '!'    <Op Unary>
               | '~'    <Op Unary>   
               | '-'    <Op Unary>
               | '*'    <Op Unary>
               | '&'    <Op Unary>               
               | <Op Pointer>

<Op Pointer> ::= <Op Pointer> '.' <Value>
               | <Op Pointer> '->' <Value>
               | <Op Pointer> '[' <Expr> ']'
               | <Value>

<Value>      ::= OctLiteral
               | HexLiteral
               | DecLiteral  
               | StringLiteral
               | CharLiteral
               | FloatLiteral
               | Id '(' <Expr> ')'
               | Id '(' ')'          

               | Id
               | '(' <Expr> ')'
