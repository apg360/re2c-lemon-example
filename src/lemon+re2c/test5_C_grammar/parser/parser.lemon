//
// C grammar in Lemon
//
// https://www.lysator.liu.se/c/ANSI-C-grammar-y.html
// https://www.lysator.liu.se/c/ANSI-C-grammar-l.html
// https://cs.au.dk/~amoeller/RegAut/JavaBNF.html
// 
// http://www.quut.com/c/ANSI-C-grammar-y.html
// https://github.com/antlr/grammars-v4/blob/master/c/C.g4
// http://www2.cs.tum.edu/projects/cup/examples.php#gast
//
// https://sqlite.org/src/file/tool/lemon.c
// https://sqlite.org/src/doc/trunk/doc/lemon.html
// https://sqlite.org/src/doc/trunk/doc/lemon.html#token_type
// http://souptonuts.sourceforge.net/readme_lemon_tutorial.html
//
////////////////////////////////////////////////////////////////////////

%syntax_error  { PARSER_STATE.error = true; fprintf(stderr, "/!\\ Syntax Error.\n"); }
%parse_failure { PARSER_STATE.error = true; fprintf(stderr, "/!\\ Parse failure.\n"); }

// must call PARSER(0, 0); to enter %parse_accept
// Formating number of digits after dot %.15lf
%parse_accept  { PARSER_STATE.error = false;
                 puts("The parser has completed successfully.");
               }

%include
{
    #include <stdio.h>   // FILE, output on screen
    #include <assert.h>  // 
    #include <stdlib.h>  // malloc, free + os access: open file, read/write file, delete file etc...
    #include <stddef.h>  // size_t
    #include <string.h>  // strlen, strcmp
    #include <stdbool.h> // bool
    #include <math.h>
    
    #include <parser.h>  // All token codes definitions, generated by grammar in lemon
    #include <token.h>   // 
    
    /// Local variables for the parser ///
    void * theParser;
    struct _parser_state PARSER_STATE;
    
    /// Internal Lemon's functions ///
    void ParseTrace(FILE *TraceFILE, char *str);
    void * ParseAlloc(
        void * (*allocProc)(size_t)             // Function used to allocate memory
    );
    void ParseFree(
        void* parser,                          // The parser to be deleted
        void(*freeProc)(void*)                 // Function used to reclaim memory
    );
    void Parse(
        void * pParser,                        // The parser
        const int pTokenID,                    // The major token code number
        const char* pTokenvalue                // Value associated with a token %token_type { const char* }
    );
    
    /// Parser Functions ///
    void PARSER_INIT(bool parser_DebugMode){
      theParser = ParseAlloc(malloc);
      if ( parser_DebugMode == true ) ParseTrace(stderr, "[Parser] >> ");
    }
    void PARSER_FREE(){ ParseFree(theParser, free); }
    
    void PARSER(const struct _scanner_state * pSCANNER_STATE){
      
      // Reset variables to initial values
      PARSER_STATE.error = false;
      
      // Start parsing
      Parse(theParser, pSCANNER_STATE->token_id, pSCANNER_STATE->token_stringvalue);
      
      // If it is end of Line, end the parser.
      // Must 'call PARSER(0, 0);' so parser enter the '%parse_accept'
      if ( TK_END_OF_LINE == pSCANNER_STATE->token_id || TK_END_OF_FILE == pSCANNER_STATE->token_id )
      { Parse(theParser, 0, 0); }
      
    } // END PARSER
    
    void println(const char * pString)
    { printf("GAZGAZ : %s\n",pString); };

} // END %include

%token_prefix TK_               // All token codes are integers with #defines that begin with "TK_"
%token_type { const char* }     // All token values are strings, they will be converted to their value type during semantic analysis.
%start_symbol program           // First grammar rule to start with

%nonassoc IDENTIFIER NUMBER_LITERAL STRING_LITERAL QUOTE SEMCOL.
%nonassoc IF ELSE TRUE FALSE FOR SWITCH RETURN BREAK CONTINUE FALLTHROUGH DEFAULT.
%nonassoc EQ NE GT GE LT LE.            // == not= > >= < <=


%left PTR_OP INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP.
%left AND_OP OR_OP STAR_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN.
%left SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN.
%left XOR_ASSIGN OR_ASSIGN TYPE_NAME.


%left AND.
%left OR.
// Math order of priority => BIDMAS : Bracket/Parenthesis Indices/Power/Order Divide Multiply Addition Substraction
%left ADD SUB.                          // PLUS MINUS
%left MUL DIV MOD.                      // DIVIDE TIMES MODULUS(remainder operator)
%left POS NEG.                          // Negation--unary minus
%left LBRACKET RBRACKET LPAREN RPAREN.  // { } ( )
%right EXP NOT.                         // 2^3^2 = 2^(3^2) = 512


/************************************************************************

                    ยง THE LEMON GRAMMAR RULES ยง
________________________________________________________________________
no compund statement ! one grammar rule is one condition, no multi option like in regular expression
Example : jump_statement        ::= BREAK expression|BREAK.
Will become
          jump_statement        ::= BREAK expression.
          jump_statement        ::= BREAK.

1.Tokens are consumed one-by-one and added to a stack
2.A reduction is performed : when a grammar rule is not ambiguous and can be applied to a sequence of one/or more terminals/non-terminals at the top of the stack
3.Goal is to reduce input to a single non-terminal


    terminals = tokens
non-terminals = names of other grammar rules (different kinds of nodes in the parse tree)


non-terminals => lower case
    terminals => UPPER CASE
________________________________________________________________________
************************************************************************/


//
program ::= input.
input ::= .
input ::= input lines.
lines ::= block_statement END_OF_LINE|END_OF_FILE.                     { println("lines ::= translation_unit END_OF_LINE|END_OF_FILE."); }

boolean_literal     ::= true | false.
type     ::= u8 | u16 | u32 | u64 | u128 | i8 | i16 | i32 | i64 | i128 | f16 | f32 | f64.

identifier_list ::= IDENTIFIER.
identifier_list ::= identifier_list COMMA IDENTIFIER.
argument_list   ::= expression.
argument_list   ::= argument_list COMMA expression.

block_statement ::= LBRACKET RBRACKET.
block_statement ::= LBRACKET statement_list RBRACKET.

statement_list ::= statement.
statement_list ::= statement_list statement.

statement ::= variable.
statement ::= ifstmt.
statement ::= forstmt.
statement ::= switchstmt.
statement ::= proc_definition.
statement ::= proc_call.

// VARIABLES //

variable ::= variable_declaration.
variable ::= variable_assignment.

variable_declaration ::= IDENTIFIER ASSIGN type.                        // var=u16
variable_declaration ::= IDENTIFIER ASSIGN type ASSIGN NUMBER_LITERAL.  // var=u16=15
variable_declaration ::= IDENTIFIER ASSIGN QUOTE STRING_LITERAL QUOTE.  // var="string"
variable_declaration ::= IDENTIFIER ASSIGN boolean_literal.             // var=true + var=false

variable_assignment  ::= IDENTIFIER ASSIGN expression.                  // existing var change value var=17
variable_assignment  ::= identifier_list ASSIGN identifier_list.        // i,j,k=a,b,c
//variable_assignment  ::= identifier_list ASSIGN expression_list.      // i,j,k=1,2,3 or i,j,k=1*2,2*2,3*3


// IF STATEMENT //

ifstmt              ::= IF expression LBRACKET block_statement RBRACKET.
ifstmt              ::= IF expression LBRACKET block_statement RBRACKET ELSE LBRACKET block_statement RBRACKET.


// FOR LOOP //

//forstmt             ::= FOR for_init SEMCOL expression SEMCOL for_update for_block_statement.
//for_init            ::= expression | variable_declaration.
//for_update          ::= expression.
//for_block_statement ::= block_statement.
//for_block_statement ::= for_jump_statement.
//for_jump_statement  ::= BREAK.
//for_jump_statement  ::= BREAK primary_expression.
//for_jump_statement  ::= CONTINUE.


// SWITCH CASE //

//switchstmt          ::= SWITCH expression LBRACKET switch_block RBRACKET.
//switch_block        ::= expression LBRACKET switch_case_block RBRACKET.
//switch_block        ::= DEFAULT    LBRACKET statement RBRACKET.         // DEFAULT {}
//switch_case_block   ::= FALLTHROUGH.
//switch_case_block   ::= statement.


// PROCEDURE //

proc_definition     ::= IDENTIFIER LPAREN RPAREN proc_statement.       // proc_add() { ... }
proc_definition     ::= IDENTIFIER LPAREN argument_list RPAREN proc_statement. // proc_add(x,y,z) { ... }
proc_statement      ::= block_statement.
proc_statement      ::= proc_return.
proc_return         ::= RETURN.                                         { println("proc_return ::= RETURN."); }
proc_return         ::= RETURN expression.                              { println("proc_return ::= RETURN expression."); }

proc_call           ::= IDENTIFIER LPAREN RPAREN.                       // proc_add()
proc_call           ::= IDENTIFIER LPAREN argument_list RPAREN.         // proc_add(x,y,z)

//=====================================================================//
//////////////////////////////////  EXPRESSIONS  ///////////////////////
//=====================================================================//

expression  ::= expression COMMA OpAssign.
expression  ::= OpAssign.

OpAssign    ::= OpOr ASSIGN       OpAssign.
OpAssign    ::= OpOr ADD_ASSIGN   OpAssign.
OpAssign    ::= OpOr SUB_ASSIGN   OpAssign.
OpAssign    ::= OpOr MUL_ASSIGN   OpAssign.
OpAssign    ::= OpOr DIV_ASSIGN   OpAssign.
OpAssign    ::= OpOr XOR_ASSIGN   OpAssign.
OpAssign    ::= OpOr AND_ASSIGN   OpAssign.
OpAssign    ::= OpOr OR_ASSIGN    OpAssign.
OpAssign    ::= OpOr RIGHT_ASSIGN OpAssign.
OpAssign    ::= OpOr LEFT_ASSIGN  OpAssign.
OpAssign    ::= OpOr.

OpOr        ::= OpOr OR_OP OpAnd.
OpOr        ::= OpAnd.

OpAnd       ::= OpAnd AND_OP OpBinOR
OpAnd       ::= OpBinOR.

OpBinOR     ::= OpBinOr PIPE OpBinXOR.
OpBinOR     ::= OpBinXOR.

OpBinXOR    ::= OpBinXOR XOR OpBinAND.
OpBinXOR    ::= OpBinAND.

OpBinAND    ::= OpBinAND REF OpEquate.
OpBinAND    ::= OpEquate.

OpEquate    ::= OpEquate EQ_OP OpCompare.
OpEquate    ::= OpEquate NE_OP OpCompare.
OpEquate    ::= OpCompare.

OpCompare   ::= OpCompare LT    OpShift.
OpCompare   ::= OpCompare GT    OpShift.
OpCompare   ::= OpCompare LE_OP OpShift.
OpCompare   ::= OpCompare GE_OP OpShift.
OpCompare   ::= OpShift.

OpShift     ::= OpShift LEFT_OP  OpAdd.
OpShift     ::= OpShift RIGHT_OP OpAdd.
OpShift     ::= OpAdd.

OpAdd       ::= OpAdd PLUS  OpMult.
OpAdd       ::= OpAdd MINUS OpMult.
OpAdd       ::= OpMult.

OpMult      ::= OpMult STAR OpUnary.
OpMult      ::= OpMult DIV  OpUnary.
OpMult      ::= OpMult MOD  OpUnary.
OpMult      ::= OpUnary.

OpUnary     ::= NOT   OpUnary.
OpUnary     ::= TILDE OpUnary.
OpUnary     ::= MINUS OpUnary.
OpUnary     ::= value.

value       ::= OCTLITERAL.
value       ::= HEXLITERAL.
value       ::= NUMBERLITERAL.
value       ::= STRINGLITERAL.
value       ::= CHARLITERAL.
value       ::= FLOATLITERAL.
value       ::= IDENTIFIER LPAREN expression RPAREN.
value       ::= IDENTIFIER LPAREN RPAREN.
value       ::= IDENTIFIER.
value       ::= LPAREN expression RPAREN.

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
