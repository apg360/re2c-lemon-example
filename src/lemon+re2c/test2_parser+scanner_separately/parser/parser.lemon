// https://sqlite.org/src/doc/trunk/doc/lemon.html
// https://sqlite.org/src/doc/trunk/doc/lemon.html#token_type
// http://souptonuts.sourceforge.net/readme_lemon_tutorial.html

%include
{
    #include <stdlib.h>
    #include <stdbool.h>
    #include <parser.h>  // All token codes definitions, generated by grammar in lemon
    #include <token.h>   // 
    
    void * theParser;
    struct _parser_state PARSER_STATE;
    
    void ParseTrace(FILE *TraceFILE, char *str);
    void * ParseAlloc(
        void* (*allocProc)(size_t)             // Function used to allocate memory
    );
    void ParseFree(
        void* parser,                          // The parser to be deleted
        void(*freeProc)(void*)                 // Function used to reclaim memory
    );
    void Parse(
        void * parser,                         // The parser
        const int token,                       // The major token code number
        const double tokenvalue,               // Value associated with a token %token_type { double }
        struct _parser_state * pPARSER_STATE   // %extra_argument parameter
    );
    
    void PARSER_INIT(bool parser_DebugMode){
      theParser = ParseAlloc(malloc);
      if (parser_DebugMode == true) ParseTrace(stderr, "[Parser] >> ");
    }
    void PARSER(const int token, const double tokenvalue){
      Parse(theParser, token, tokenvalue, &PARSER_STATE);
    }
    void PARSER_FREE(){
      ParseFree(theParser, free);
    }

} // end %include

%extra_argument { struct _parser_state * PARSER_STATE }
%token_prefix TK_ // All token codes are integers with #defines that begin with "TK_"

%token_type      { double }

%left ADD SUB.       //PLUS  MINUS
%left MUL DIV.       //TIMES DIVIDE

// This is to terminate with a new line, the grammar dictate when the expression can no longer be reduced.
// Without this PARSER(0, 0); Parse(pParse,0,0) have to be called to signal the end of the input for an expression
start ::= in.
in ::= .
in ::= in program NEWLINE. // NEWLINE is EOL : end of line

program ::= expr(A).   { PARSER_STATE->result_value.number = A; }

expr(X) ::= expr(A) ADD  expr(B).    { X = A + B; }
expr(X) ::= expr(A) SUB  expr(B).    { X = A - B; }
expr(X) ::= expr(A) MUL  expr(B).    { X = A * B; }
expr(X) ::= expr(A) DIV  expr(B).    { if(B != 0){ X = A / B; 
                                       }else{ printf("divide by zero" ); PARSER_STATE->error = true;} 
                                     }// end of DIVIDE

expr(X) ::= LPAREN expr(A) RPAREN.   { X = A; }

expr(X) ::= INT_LITERAL(A).          { X = A; }

%parse_accept  { PARSER_STATE->error = false; printf("Result : %f\n",PARSER_STATE->result_value.number); printf("The parser has completed successfully.\n"); } // must do PARSER(0, 0); to enter parse_accept
%syntax_error  { PARSER_STATE->error = true; fprintf(stderr, "Syntax Error.\n"); }
%parse_failure { PARSER_STATE->error = true; fprintf(stderr, "Parse failure.\n"); }
