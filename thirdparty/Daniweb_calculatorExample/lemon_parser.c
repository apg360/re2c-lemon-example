/*
 * this is the "main part" of the parser
 * gets concatenated to parser.c, which is generated by lemon parser.y
 */
 
/*
 * include types, we do it here for the sake of obviousness,
 * these headers are actually included by parser.c, which is
 * generated by parser.y
 */
#include "scanner.h"
#include "parser.h"
#include "lemon_parser.h"
 
scanner_token parse_math_expr(char* s) {
    scanner_token *token;
    scanner_state *state;
    int stat;
    //TODO: fix memory leaks
    void* pParser = ParseAlloc(malloc);
    //do similar things to handcrafted_parser.c
    state = malloc(sizeof(scanner_state));
    token = malloc(sizeof(scanner_token));
    if(NULL == state  || NULL == token) {
        return *token;
    }
    state->start = s;
    while(0 <= (stat = scan(state,token))) {
        switch(token->opcode) {
            case TOKEN_INTEGER:
                printf("\tscanner says: %d\n",token->data.n);
                Parse(pParser,OP_INTEGER,token);
                break;
            case TOKEN_ADD:
                printf("\tscanner: %c\n",token->opcode);
                Parse(pParser,OP_ADD,token);
                break;
            case TOKEN_SUB:
                printf("\tscanner: %c\n",token->opcode);
                Parse(pParser,OP_SUB,token);
                break;
            case TOKEN_MUL:
                printf("\tscanner: %c\n",token->opcode);
                Parse(pParser,OP_MUL,token);
                break;
            case TOKEN_DIV:
                printf("\tscanner: %c\n",token->opcode);
                Parse(pParser,OP_DIV,token);
                break;
                /*
            case OP_ROUND_BRACKET_OPEN:
                printf("\tscanner: %c\n",token->opcode);
                break;
            case OP_ROUND_BRACKET_CLOSE:
                printf("\tscanner: %c\n",token->opcode);
                break;
                */
            default:
                printf("\tscanner: unknown opcode: %c\n",token->opcode);
                break;
        }
        //it's here, but not used:
        state->end = state->start;
    }
    Parse(pParser,0,0);
    return *token;
}
